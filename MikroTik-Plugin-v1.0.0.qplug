-- MikroTik RouterOS API Plugin
-- by Hori Shogo, with contributions from John Ellis
-- May 2025

-- Information block for the plugin
PluginInfo = {
  Version = "1.0.0",
  BuildVersion = "1.0.0.0",
  Id = "09c228c2-a33b-46f4-a46f-6ec28b809ca1",--<guid>
  Author = "Hori Shogo",
}
PluginInfo.Name = "MikroTik~MikroTik RouterOS API " .. PluginInfo.Version
PluginInfo.Description = "Mikrotik RouterOS API \n"..PluginInfo.Version

function GetColor(props) return { 0, 0, 0 } end

function GetPrettyName(props)
  return "MikroTik RouterOS API \nv" .. PluginInfo.Version .. ",\nTotal " .. tostring(props["Total Interfaces"].Value) .. " Port"
end

local PageNames = {}
function GetPages(props)
  local pages = {}
  local pageNames = {}
  -- always show the Setup page
  table.insert(pages, { name = "Setup" })
  table.insert(pageNames, "Setup")
  -- get max interfaces as a number
  local maxIf     = tonumber(props["Total Interfaces"].Value) or 0
  local perPage   = 16
  local totalPages = math.ceil(maxIf / perPage)
  -- create one page per 16 interfaces
  for i = 1, totalPages do
    local startIf = (i - 1) * perPage + 1
    local endIf   = math.min(i * perPage, maxIf)
    local label   = string.format("Interfaces %d-%d", startIf, endIf)
    table.insert(pages, { name = label })
    table.insert(pageNames,  label)
  end
  -- always show Event Log
  table.insert(pages, { name = "Event Log" })
  table.insert(pageNames, "Event Log")
  -- optionally show SSH Terminal if enabled
  if props["Enable SSH Terminal"].Value then
    table.insert(pages, { name = "SSH Terminal" })
    table.insert(pageNames, "SSH Terminal")
  end
  
  PageNames = pageNames
  return pages
end

-- Define User configurable Properties of the plugin
function GetProperties()
  local props = {}
  table.insert(props, {
    Name = "Total Interfaces",
    Type = "integer",
    Min = 5,
    Max = 1023,
    Value = 18,
    Header = "Value must be number between 5 and 1023",
    --Comment = "Value must be number between 5 and 1023"
  })
  table.insert(props, {
    Name = "Connection Type",
    Type = "enum",
    Choices = {"TCP", "TLS"},
    Value = "TCP",
    Header  = "Choose TCP or TLS for the API connection",
  })
  table.insert(props, {
    Name = "Enable SSH Terminal",
    Type = "boolean",
    Value = false
  })
  table.insert(props, {
    Name = "Port Information",
    Type = "enum",
    Choices = {"Basic", "Basic+PoE", "Basic+PoE+Packets"},
    Value = "Basic"
  })
  table.insert(props, {
    Name = "Poll Rate(sec)",
    Type = "integer",
    Min = 1,
    Max = 600,
    Value = 3,
    Header = "Value must be number between 1 and 600",
    --Comment = "Value must be number between 1 and 600"
  })
  table.insert(props, {
    Name = "Debug Print",
    Type = "enum",
    Choices = {"None", "Tx/Rx", "Tx", "Rx", "Function", "All"},
    Value = "All"
  })
  return props
end

function RectifyProperties(props)
  if props.plugin_show_debug.Value == false then
    props["Debug Print"].IsHidden = true
  end
  return props
end

-- Defines the Controls used within the plugin
function GetControls(props)
  local ctrls = {}
  local TextControls = {
    Name = {"IPAddress","APIUsername","APIPassword","InterfaceToCore","SystemName","SoftwareID","nLevel","FactoryFirmwareVersion","FirmwareVersion","Uptime","BoardName","Model","SerialNumber","FirmewareType",
  "SSHUsername","SSHPassword","RealSSHPass","SSHTimeOutDisplay","SSHInput","SSHOutput","LogMsg"},
    PinStyle = {"Both","Both","Both","Both","Output","Output","Output","Output","Output","Output","Output","Output","Output","Output","Output",
  "Both","Both","None","Both","Output","Both","Output","Output"}
  }
  local ButtonControls = {
    Name = {"Enable/Disable Port","Enable/Disable PoE"},
  }
  local TriButtonControls = {
    Name = {"SSHConnect","SSHClear","SSHDisconnect","SSHSend","GetLog","LogClear","Reboot"},
  }
  local IndicatorControls = {
    Name = {"Running","PoeStatus","SSHConnected"},
    Count = {props["Total Interfaces"].Value,props["Total Interfaces"].Value,1},
  }
  local ReadControls = {
    Name = {"Interface","Comment","PortLabel","PoeMode","LinkSpeed","ReceivedByte","ReceivedUnicast","ReceivedMulticast","ReceivedBroadcast","ReceivedError",
    "TransmittedByte","TransmittedUnicast","TransmittedMulticast","TransmittedBroadcast","TransmittedDropped",
    "DeviceMAC","PoeVoltage","PoeOutStatus","PoeOutVoltage","PoeOutCurrent","PoeOutPower"}
  }
  
  --Arrays of Controls
  for i=1,#TextControls.Name do
    table.insert(ctrls, {
      Name = TextControls.Name[i],
      ControlType = "Text",
      Count = 1,
      UserPin = true,
      PinStyle = TextControls.PinStyle[i],
    })
  end
  for i=1,#ButtonControls.Name do
    table.insert(ctrls, {
      Name = ButtonControls.Name[i],
      ControlType = "Button",
      ButtonType = "Toggle",
      Count = props["Total Interfaces"].Value,
      UserPin = true,
      PinStyle = "Both",
    })
  end
  for i=1,#TriButtonControls.Name do
    table.insert(ctrls, {
      Name = TriButtonControls.Name[i],
      ControlType = "Button",
      ButtonType = "Trigger",
      Count = 1,
      IconType = TriButtonControls.Name[i]=="SSHSend" and "Icon" or nil,
      Icon = TriButtonControls.Name[i]=="SSHSend" and "Arrow Right" or nil,
      UserPin = true,
      PinStyle = "Both",
    })
  end
  for i=1,#IndicatorControls.Name do
    table.insert(ctrls, {
      Name = IndicatorControls.Name[i],
      ControlType = "Indicator",
      IndicatorType = "Led",
      Count = IndicatorControls.Count[i],
      UserPin = true,
      PinStyle = "Output",
    })
  end
  for i=1,#ReadControls.Name do
    table.insert(ctrls, {
      Name = ReadControls.Name[i],
      ControlType = "Text",
      Count = props["Total Interfaces"].Value,
      UserPin = true,
      PinStyle = i==2 and "Both" or "Output",
    })
  end
  
  ----------------------------------------------------------------
  table.insert(ctrls, { Name = "SSHTimeOut", ControlType = "Knob", ControlUnit = "Integer", Count = 1, DefaultValue = 30, Max = 120, Min = 0, UserPin = true, PinStyle = "Output",})
  table.insert(ctrls, { Name = "Status", ControlType = "Indicator", IndicatorType = "Status", Count = 1, UserPin = true, PinStyle = "Output",})
  return ctrls
end

--Layout of controls and graphics for the plugin UI to display
function GetControlLayout(props)
  local layout = {}
  local graphics = {}
  local pageIndex   = props["page_index"].Value
  local CurrentPage = PageNames[pageIndex]
  local maxIf       = tonumber(props["Total Interfaces"].Value) or 0
  local perPage     = 16
  local totalPages  = math.ceil(maxIf / perPage)
  local firstIntPg  = 2
  local lastIntPg   = firstIntPg + totalPages - 1
  local eventPg     = lastIntPg + 1
  local sshPg       = eventPg + (props["Enable SSH Terminal"].Value and 1 or 0)
  local Colors = {
    Black = {0,0,0}, White = {255,255,255}, Red = {255,0,0}, Blue = {16,16,255}, LightBlue = {141,207,244}, Gray = {105,105,105}, LightGray = {194,194,194}, HGray = {153,153,153}, OffGray = {124,124,124},
    LightYellow = {254,248,134}, Orange = {245,186,92}, BtnGray = {51,51,51}, Background = {230,230,230}, OnlineGreen = {34,178,76}, White0 = {255,255,255,0}, Black0 = {0,0,0,0},
  }
  local zOerders = {back=-100, zero=0, layer10=10, layer20=20, labels=100, ctrl=200, front=1000}
  local labels = {size={130,18}, size2={100,20}, size3={205,20}}
  local clabels = {size={185,18}, size2={112,16}}
  local btns = {size={50,20}, size2={40,20}}
  local leds = {size={20,20}}
  
  local made_logo = "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgd2lkdGg9IjI5My44MjQwNCIKICAgaGVpZ2h0PSIzOC4wMDAwMDQiCiAgIHZpZXdCb3g9IjAgMCAyOTMuODI0MDQgMzguMDAwMDA0IgogICBmaWxsPSJub25lIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmcxODM1IgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxkZWZzCiAgICAgaWQ9ImRlZnMyMDY4IiAvPgogIDxwYXRoCiAgICAgZD0ibSA1NC4xODE1OTEsMjMuMDAyMTU0IHYgLTcuNTYgaCAxLjY4IHYgMS44NDggbCAtMC4xODE5LC0wLjIzOCBjIDAuMDk4LC0wLjI2MTMgMC4yMjg2LC0wLjQ5OTMgMC4zOTE5LC0wLjcxNCAwLjE2MzQsLTAuMjE0NiAwLjM2NCwtMC4zOTIgMC42MDIsLTAuNTMyIDAuMTgyLC0wLjExMiAwLjM4MDQsLTAuMTk4MyAwLjU5NTEsLTAuMjU5IDAuMjE0NiwtMC4wNjUzIDAuNDM2MywtMC4xMDUgMC42NjUsLTAuMTE5IDAuMjI4NiwtMC4wMTg2IDAuNDU3MywtMC4wMTQgMC42ODU5LDAuMDE0IHYgMS43NzggYyAtMC4yMSwtMC4wNjUzIC0wLjQ1NSwtMC4wODYzIC0wLjczNSwtMC4wNjMgLTAuMjc1MywwLjAxODcgLTAuNTI0OSwwLjA4MTcgLTAuNzQ4OSwwLjE4OSAtMC4yMjQsMC4xMDI3IC0wLjQxMywwLjI0MDQgLTAuNTY3LDAuNDEzIC0wLjE1NCwwLjE2OCAtMC4yNzA3LDAuMzY4NyAtMC4zNTAxLDAuNjAyIC0wLjA3OTMsMC4yMjg3IC0wLjExOSwwLjQ4NzcgLTAuMTE5LDAuNzc3IHYgMy44NjQgeiIKICAgICBmaWxsPSIjMGUwZTEwIgogICAgIGlkPSJwYXRoMTgxMCIgLz4KICA8cGF0aAogICAgIGQ9Im0gNDguODA2MjkxLDIzLjIxMTQ1NCBjIC0wLjc2MDcsMCAtMS40MjgsLTAuMTcwMyAtMi4wMDIsLTAuNTExIC0wLjU3NCwtMC4zNDA3IC0xLjAyMiwtMC44MDk3IC0xLjM0NCwtMS40MDcgLTAuMzE3NCwtMC42MDIgLTAuNDc2LC0xLjI5MjcgLTAuNDc2LC0yLjA3MiAwLC0wLjc4ODcgMC4xNjMzLC0xLjQ4MTcgMC40OSwtMi4wNzkgMC4zMjY2LC0wLjYwMiAwLjc3NywtMS4wNzEgMS4zNTEsLTEuNDA3IDAuNTc0LC0wLjMzNiAxLjIzNDMsLTAuNTA0IDEuOTgxLC0wLjUwNCAwLjc2MDYsMCAxLjQyOCwwLjE3MDMgMi4wMDIsMC41MTEgMC41Nzg2LDAuMzQwNyAxLjAyOSwwLjgxMiAxLjM1MSwxLjQxNCAwLjMyMiwwLjU5NzMgMC40ODMsMS4yODU3IDAuNDgzLDIuMDY1IDAsMC43ODQgLTAuMTYzNCwxLjQ3NyAtMC40OSwyLjA3OSAtMC4zMjIsMC41OTczIC0wLjc3MjQsMS4wNjYzIC0xLjM1MSwxLjQwNyAtMC41NzQsMC4zMzYgLTEuMjM5LDAuNTA0IC0xLjk5NSwwLjUwNCB6IG0gMCwtMS43NzggYyAwLjYxMTMsMCAxLjA2NjMsLTAuMjA1MyAxLjM2NSwtMC42MTYgMC4zMDMzLC0wLjQxNTMgMC40NTUsLTAuOTQ3MyAwLjQ1NSwtMS41OTYgMCwtMC42NzIgLTAuMTU0LC0xLjIwODcgLTAuNDYyLC0xLjYxIC0wLjMwMzQsLTAuNDAxMyAtMC43NTYsLTAuNjAyIC0xLjM1OCwtMC42MDIgLTAuNDE1NCwwIC0wLjc1NiwwLjA5MzMgLTEuMDIyLDAuMjggLTAuMjY2LDAuMTg2NyAtMC40NjQ0LDAuNDQ1NyAtMC41OTUsMC43NzcgLTAuMTI2LDAuMzMxMyAtMC4xODksMC43MTYzIC0wLjE4OSwxLjE1NSAwLDAuNjc2NyAwLjE1MTYsMS4yMTU3IDAuNDU1LDEuNjE3IDAuMzA4LDAuMzk2NyAwLjc1ODMsMC41OTUgMS4zNTEsMC41OTUgeiIKICAgICBmaWxsPSIjMGUwZTEwIgogICAgIGlkPSJwYXRoMTgxMiIgLz4KICA8cGF0aAogICAgIGQ9Im0gNDAuOTA3MjkxLDIzLjAwMTk1NCB2IC03LjUzMiBjIDAsLTAuMTkxNCAwLjAwNDcsLTAuNDA4NCAwLjAxNCwtMC42NTEgMC4wMDkzLC0wLjI0MjcgMC4wNDY3LC0wLjQ4NzcgMC4xMTIsLTAuNzM1IDAuMDcsLTAuMjQ3NCAwLjE5NiwtMC40NzE0IDAuMzc4LC0wLjY3MiAwLjIzMzMsLTAuMjYxNCAwLjQ4NTMsLTAuNDM4NyAwLjc1NiwtMC41MzIgMC4yNzUzLC0wLjA5OCAwLjU0MTMsLTAuMTQ5NCAwLjc5OCwtMC4xNTQgMC4yNTY3LC0wLjAwOTQgMC40NzYsLTAuMDE0IDAuNjU4LC0wLjAxNCBoIDAuOTM4IHYgMS41NCBoIC0wLjg2OCBjIC0wLjI5ODcsMCAtMC41MjAzLDAuMDc3IC0wLjY2NSwwLjIzMSAtMC4xNDQ3LDAuMTQ5MyAtMC4yMTcsMC4zMjkgLTAuMjE3LDAuNTM5IHYgNy45OCB6IG0gLTEuMTksLTYuMDkgdiAtMS40NyBoIDQuODQ0IHYgMS40NyB6IgogICAgIGZpbGw9IiMwZTBlMTAiCiAgICAgaWQ9InBhdGgxODE0IiAvPgogIDxwYXRoCiAgICAgZD0ibSAzMi40NzA5OTEsMjMuMjExNDU0IGMgLTAuNzc0NywwIC0xLjQ1ODMsLTAuMTY1NyAtMi4wNTEsLTAuNDk3IC0wLjU4OCwtMC4zMzYgLTEuMDUsLTAuNzk1NyAtMS4zODYsLTEuMzc5IC0wLjMzMTMsLTAuNTg4IC0wLjQ5NywtMS4yNiAtMC40OTcsLTIuMDE2IDAsLTAuODI2IDAuMTYzMywtMS41NDQ3IDAuNDksLTIuMTU2IDAuMzI2NywtMC42MTEzIDAuNzc3LC0xLjA4NSAxLjM1MSwtMS40MjEgMC41NzQsLTAuMzQwNyAxLjIzNDMsLTAuNTExIDEuOTgxLC0wLjUxMSAwLjc5MzMsMCAxLjQ2NzcsMC4xODY3IDIuMDIzLDAuNTYgMC41NTUzLDAuMzczMyAwLjk2NiwwLjg5ODMgMS4yMzIsMS41NzUgMC4yNjYsMC42NzY3IDAuMzU5MywxLjQ3MjMgMC4yOCwyLjM4NyBoIC0xLjg4MyB2IC0wLjcgYyAwLC0wLjc3IC0wLjEyMzcsLTEuMzIzIC0wLjM3MSwtMS42NTkgLTAuMjQyNywtMC4zNDA3IC0wLjY0MTcsLTAuNTExIC0xLjE5NywtMC41MTEgLTAuNjQ4NywwIC0xLjEyNywwLjE5ODMgLTEuNDM1LDAuNTk1IC0wLjMwMzMsMC4zOTIgLTAuNDU1LDAuOTczIC0wLjQ1NSwxLjc0MyAwLDAuNzA0NyAwLjE1MTcsMS4yNTA3IDAuNDU1LDEuNjM4IDAuMzA4LDAuMzgyNyAwLjc1ODMsMC41NzQgMS4zNTEsMC41NzQgMC4zNzMzLDAgMC42OTMsLTAuMDgxNyAwLjk1OSwtMC4yNDUgMC4yNjYsLTAuMTYzMyAwLjQ2OSwtMC4zOTkgMC42MDksLTAuNzA3IGwgMS45MDQsMC41NDYgYyAtMC4yODQ3LDAuNjkwNyAtMC43MzUsMS4yMjczIC0xLjM1MSwxLjYxIC0wLjYxMTMsMC4zODI3IC0xLjI4MSwwLjU3NCAtMi4wMDksMC41NzQgeiBtIC0yLjUwNiwtMy40NTggdiAtMS40MTQgaCA1LjAxMiB2IDEuNDE0IHoiCiAgICAgZmlsbD0iIzBlMGUxMCIKICAgICBpZD0icGF0aDE4MTYiIC8+CiAgPHBhdGgKICAgICBkPSJtIDIzLjI3Mjk5MSwyMy4yMTE4NTQgYyAtMC42OTUzLDAgLTEuMzA0MywtMC4xNzUgLTEuODI3LC0wLjUyNSAtMC41MjI3LC0wLjM1IC0wLjkzMSwtMC44MjYgLTEuMjI1LC0xLjQyOCAtMC4yODkzLC0wLjYwMiAtMC40MzQsLTEuMjgxIC0wLjQzNCwtMi4wMzcgMCwtMC43NyAwLjE0NywtMS40NTM2IDAuNDQxLC0yLjA1MSAwLjI5ODcsLTAuNjAyIDAuNzE2MywtMS4wNzU2IDEuMjUzLC0xLjQyMSAwLjUzNjcsLTAuMzQ1MyAxLjE2NjcsLTAuNTE4IDEuODksLTAuNTE4IDAuNzE4NywwIDEuMzIzLDAuMTc1IDEuODEzLDAuNTI1IDAuNDksMC4zNSAwLjg2MSwwLjgyNiAxLjExMywxLjQyOCAwLjI1MiwwLjYwMiAwLjM3OCwxLjI4MSAwLjM3OCwyLjAzNyAwLDAuNzU2IC0wLjEyODMsMS40MzUgLTAuMzg1LDIuMDM3IC0wLjI1MiwwLjYwMiAtMC42MywxLjA3OCAtMS4xMzQsMS40MjggLTAuNTA0LDAuMzUgLTEuMTMxNywwLjUyNSAtMS44ODMsMC41MjUgeiBtIDAuMzA4LC0xLjY5NCBjIDAuNDI0NywwIDAuNzYzLC0wLjA5NTYgMS4wMTUsLTAuMjg3IDAuMjU2NywtMC4xOTEzIDAuNDQxLC0wLjQ1OTYgMC41NTMsLTAuODA1IDAuMTEyLC0wLjM0NTMgMC4xNjgsLTAuNzQ2NiAwLjE2OCwtMS4yMDQgMCwtMC40NTczIC0wLjA1NiwtMC44NTg2IC0wLjE2OCwtMS4yMDQgLTAuMTEyLC0wLjM0NTMgLTAuMjkxNywtMC42MTM2IC0wLjUzOSwtMC44MDUgLTAuMjQyNywtMC4xOTEzIC0wLjU2MjMsLTAuMjg3IC0wLjk1OSwtMC4yODcgLTAuNDI0NywwIC0wLjc3NDcsMC4xMDUgLTEuMDUsMC4zMTUgLTAuMjcwNywwLjIwNTQgLTAuNDcxMywwLjQ4MyAtMC42MDIsMC44MzMgLTAuMTMwNywwLjM0NTQgLTAuMTk2LDAuNzI4IC0wLjE5NiwxLjE0OCAwLDAuNDI0NyAwLjA2MywwLjgxMiAwLjE4OSwxLjE2MiAwLjEyNiwwLjM0NTQgMC4zMTk3LDAuNjIwNyAwLjU4MSwwLjgyNiAwLjI2MTMsMC4yMDU0IDAuNTk3MywwLjMwOCAxLjAwOCwwLjMwOCB6IG0gMS43MzYsMS40ODQgdiAtNS4xOCBoIC0wLjIzOCB2IC00LjkgaCAxLjkxOCB2IDEwLjA4IHoiCiAgICAgZmlsbD0iIzBlMGUxMCIKICAgICBpZD0icGF0aDE4MTgiIC8+CiAgPHBhdGgKICAgICBkPSJtIDE0LjE0NDg5MSwyMy4yMTE0NTQgYyAtMC41NDEzLDAgLTEuMDAxLC0wLjEwMjcgLTEuMzc5LC0wLjMwOCAtMC4zNzMzLC0wLjIxIC0wLjY1OCwtMC40ODc3IC0wLjg1NCwtMC44MzMgLTAuMTkxMywtMC4zNSAtMC4yODcsLTAuNzM1IC0wLjI4NywtMS4xNTUgMCwtMC4zNSAwLjA1MzcsLTAuNjY5NyAwLjE2MSwtMC45NTkgMC4xMDczLC0wLjI4OTMgMC4yOCwtMC41NDM3IDAuNTE4LC0wLjc2MyAwLjI0MjcsLTAuMjI0IDAuNTY3LC0wLjQxMDcgMC45NzMsLTAuNTYgMC4yOCwtMC4xMDI3IDAuNjEzNywtMC4xOTM3IDEuMDAxLC0wLjI3MyAwLjM4NzMsLTAuMDc5MyAwLjgyNiwtMC4xNTQgMS4zMTYsLTAuMjI0IDAuNDksLTAuMDc0NyAxLjAyOSwtMC4xNTYzIDEuNjE3LC0wLjI0NSBsIC0wLjY4NiwwLjM3OCBjIDAsLTAuNDQ4IC0wLjEwNzMsLTAuNzc3IC0wLjMyMiwtMC45ODcgLTAuMjE0NywtMC4yMSAtMC41NzQsLTAuMzE1IC0xLjA3OCwtMC4zMTUgLTAuMjgsMCAtMC41NzE3LDAuMDY3NyAtMC44NzUsMC4yMDMgLTAuMzAzMywwLjEzNTMgLTAuNTE1NywwLjM3NTcgLTAuNjM3LDAuNzIxIGwgLTEuNzIyLC0wLjU0NiBjIDAuMTkxMywtMC42MjUzIDAuNTUwNywtMS4xMzQgMS4wNzgsLTEuNTI2IDAuNTI3MywtMC4zOTIgMS4yNDYsLTAuNTg4IDIuMTU2LC0wLjU4OCAwLjY2NzMsMCAxLjI2LDAuMTAyNyAxLjc3OCwwLjMwOCAwLjUxOCwwLjIwNTMgMC45MSwwLjU2IDEuMTc2LDEuMDY0IDAuMTQ5MywwLjI4IDAuMjM4LDAuNTYgMC4yNjYsMC44NCAwLjAyOCwwLjI4IDAuMDQyLDAuNTkyNyAwLjA0MiwwLjkzOCB2IDQuNjIgaCAtMS42NjYgdiAtMS41NTQgbCAwLjIzOCwwLjMyMiBjIC0wLjM2ODcsMC41MDg3IC0wLjc2NzcsMC44NzczIC0xLjE5NywxLjEwNiAtMC40MjQ3LDAuMjI0IC0wLjk2MzcsMC4zMzYgLTEuNjE3LDAuMzM2IHogbSAwLjQwNiwtMS40OTggYyAwLjM1LDAgMC42NDQsLTAuMDYwNyAwLjg4MiwtMC4xODIgMC4yNDI3LC0wLjEyNiAwLjQzNCwtMC4yNjgzIDAuNTc0LC0wLjQyNyAwLjE0NDcsLTAuMTU4NyAwLjI0MjcsLTAuMjkxNyAwLjI5NCwtMC4zOTkgMC4wOTgsLTAuMjA1MyAwLjE1NCwtMC40NDMzIDAuMTY4LC0wLjcxNCAwLjAxODcsLTAuMjc1MyAwLjAyOCwtMC41MDQgMC4wMjgsLTAuNjg2IGwgMC41NiwwLjE0IGMgLTAuNTY0NywwLjA5MzMgLTEuMDIyLDAuMTcyNyAtMS4zNzIsMC4yMzggLTAuMzUsMC4wNjA3IC0wLjYzMjMsMC4xMTY3IC0wLjg0NywwLjE2OCAtMC4yMTQ3LDAuMDUxMyAtMC40MDM3LDAuMTA3MyAtMC41NjcsMC4xNjggLTAuMTg2NywwLjA3NDcgLTAuMzM4MywwLjE1NjMgLTAuNDU1LDAuMjQ1IC0wLjExMiwwLjA4NCAtMC4xOTYsMC4xNzczIC0wLjI1MiwwLjI4IC0wLjA1MTMsMC4xMDI3IC0wLjA3NywwLjIxNyAtMC4wNzcsMC4zNDMgMCwwLjE3MjcgMC4wNDIsMC4zMjIgMC4xMjYsMC40NDggMC4wODg3LDAuMTIxMyAwLjIxMjMsMC4yMTQ3IDAuMzcxLDAuMjggMC4xNTg3LDAuMDY1MyAwLjM0NzcsMC4wOTggMC41NjcsMC4wOTggeiIKICAgICBmaWxsPSIjMGUwZTEwIgogICAgIGlkPSJwYXRoMTgyMCIgLz4KICA8cGF0aAogICAgIGQ9Im0gMCwyMy4wMDE4NTQgdiAtMTAuMDggaCAxLjcwODAwMTQgbCAzLjMzMiw2LjY5MiAzLjMzMiwtNi42OTIgaCAxLjcwNzk4OTYgdiAxMC4wOCBIIDguMzAyMDAxNCB2IC02LjAyIGwgLTIuOTI2LDYuMDIgaCAtMC42NzIgbCAtMi45MjYsLTYuMDIgdiA2LjAyIHoiCiAgICAgZmlsbD0iIzBlMGUxMCIKICAgICBpZD0icGF0aDE4MjIiIC8+CiAgPHBhdGgKICAgICBkPSJtIDIxMS4yMDkxOSwxMS40MjMyNTQgdiAyLjEyOTEgYyAwLDAuNDAwMiAtMC4zMiwwLjcxNTMgLTAuNzE1LDAuNjk4MyAtMC41OTgsLTAuMDI1NiAtMS40MywtMC4wNTExIC0xLjkzNSwtMC4wNTk2IC0yLjg1MiwwIC00LjQyNiwxLjcyMDMgLTQuNDI2LDQuODQ1OCB2IDcuNzQ5OSBjIDAsMC4zODMyIC0wLjMxMSwwLjY5ODMgLTAuNjksMC42OTgzIGggLTIuNDk4IGMgLTAuMzc5LDAgLTAuNjksLTAuMzE1MSAtMC42OSwtMC42OTgzIHYgLTE1LjU2NzkgYyAwLC0wLjM4MzMgMC4zMTEsLTAuNjk4NCAwLjY5LC0wLjY5ODQgaCAyLjM4MSBjIDAuMzc4LDAgMC42ODksMC4zMTUxIDAuNjg5LDAuNjk4NCB2IDAuOTg3OSBjIDEuMTM2LC0xLjE5MjMgMi45NjIsLTEuODM5NiA1LjIwOCwtMS44Mzk2IDAuMzcxLDAgMC44NDIsMC4wNTExIDEuMTcsMC4xMDIyIDAuNDYzLDAuMDU5NiAwLjgxNiwwLjQ2ODQgMC44MTYsMC45NDUzIHogbSAtMjUuNTk0LDYuNTQ5IGMgLTAuMTM0LC0wLjE3ODggLTAuMTE4LC0wLjQyNTggMC4wMzQsLTAuNTc5MSBsIDYuMTUsLTYuMTIzMiBjIDAuMjc4LC0wLjI3MjYgMC4wODQsLTAuNzQ5NSAtMC4zMDMsLTAuNzQ5NSBoIC0zLjU4NCBjIC0wLjE3NywwIC0wLjMzNiwwLjA2ODIgLTAuNDYzLDAuMTg3NCBsIC02LjkzMiw2LjQzODQgYyAtMC4yNzgsMC4yNTU0IC0wLjcyNCwwLjA1OTYgLTAuNzI0LC0wLjMyMzcgdiAtNS42MDM3IGMgMCwtMC4zODMzIC0wLjMxMSwtMC42OTg0IC0wLjY5LC0wLjY5ODQgaCAtMi40OTkgYyAtMC4zNzgsMCAtMC42ODksMC4zMTUxIC0wLjY4OSwwLjY5ODQgdiAxNS41NTk0IGMgMCwwLjM4MzIgMC4zMTEsMC42OTgzIDAuNjg5LDAuNjk4MyBoIDIuNDk5IGMgMC4zODcsMCAwLjY5LC0wLjMxNTEgMC42OSwtMC43MDY5IGwgLTAuMDI1LC0zLjYxMDkgYyAwLC0wLjE5NTkgMC4wNzYsLTAuMzgzMiAwLjIxOSwtMC41MTk1IGwgMi4xNTMsLTIuMDI2OSBjIDAuMTg2LC0wLjE3MDMgMC40NzIsLTAuMTUzMyAwLjYzMSwwLjA0MjYgbCA1LjIwOCw2LjU0OTEgYyAwLjEzNSwwLjE2MTggMC4zMjksMC4yNjQgMC41MzksMC4yNjQgaCAzLjU5MiBjIDAuMzYyLDAgMC41NjQsLTAuNDE3MyAwLjMzNywtMC43MDY5IGwgLTYuODQ5LC04Ljc5NzQgeiBtIC0yMC40MTEsLTcuNDUxOCBoIC0yLjQ5OSBjIC0wLjM3OCwwIC0wLjY5LDAuMzE1MSAtMC42OSwwLjY5ODQgdiAxNS41NTk0IGMgMCwwLjM4MzIgMC4zMTIsMC42OTgzIDAuNjksMC42OTgzIGggMi40OTkgYyAwLjM3OSwwIDAuNjksLTAuMzE1MSAwLjY5LC0wLjY5ODMgdiAtMTUuNTU5NCBjIDAsLTAuMzgzMyAtMC4zMTEsLTAuNjk4NCAtMC42OSwtMC42OTg0IHogbSA4OS42MTIsMCBoIC0xNS4xMDIgYyAtMC4zNzksMCAtMC42OSwwLjMxNTEgLTAuNjksMC42OTg0IHYgMi4yNjUzIGMgMCwwLjM4MzMgMC4zMTEsMC42OTg0IDAuNjksMC42OTg0IGggNS4xMzIgYyAwLjIzNiwwIDAuNDI5LDAuMTk1OCAwLjQyOSwwLjQzNDMgdiAxMi4xNjE0IGMgMCwwLjM4MzIgMC4zMTEsMC42OTgzIDAuNjksMC42OTgzIGggMi41OTEgYyAwLjM3OSwwIDAuNjksLTAuMzE1MSAwLjY5LC0wLjY5ODMgdiAtMTIuMTYxNCBjIDAsLTAuMjM4NSAwLjE5NCwtMC40MzQzIDAuNDI5LC0wLjQzNDMgaCA1LjEzMyBjIDAuMzc4LDAgMC42ODksLTAuMzE1MSAwLjY4OSwtMC42OTg0IHYgLTIuMjY1MyBjIDAsLTAuMzgzMyAtMC4zMTEsLTAuNjk4NCAtMC42ODksLTAuNjk4NCB6IG0gLTIxLjAxNyw4LjQ3MzggYyAwLDUuMDE2MSAtMy42NDMsOC42NjExIC04LjY3NCw4LjY2MTEgLTUuMDMxLDAgLTguNywtMy42NDUgLTguNywtOC42NjExIDAsLTUuMDE2MSAzLjY2LC04LjYyNzEgOC43LC04LjYyNzEgNS4wNCwwIDguNjc0LDMuNjI4IDguNjc0LDguNjI3MSB6IG0gLTMuOTEyLDAgYyAwLC0zLjAyMzMgLTEuOTEsLTUuMDU4NyAtNC43NjIsLTUuMDU4NyAtMi44NTIsMCAtNC43ODcsMi4wNzggLTQuNzg3LDUuMDU4NyAwLDIuOTgwNyAxLjk2OCw1LjA4NDMgNC43ODcsNS4wODQzIDIuODE4LDAgNC43NjIsLTIuMDk1MSA0Ljc2MiwtNS4wODQzIHogbSAzNi41OSwtOC40NzM4IGggLTIuNDk5IGMgLTAuMzc4LDAgLTAuNjksMC4zMTUxIC0wLjY5LDAuNjk4NCB2IDE1LjU1OTQgYyAwLDAuMzgzMiAwLjMxMiwwLjY5ODMgMC42OSwwLjY5ODMgaCAyLjQ5OSBjIDAuMzc5LDAgMC42OSwtMC4zMTUxIDAuNjksLTAuNjk4MyB2IC0xNS41NTk0IGMgMCwtMC4zODMzIC0wLjMxMSwtMC42OTg0IC0wLjY5LC0wLjY5ODQgeiBtIC0xMjEuNDQ4LC0wLjE1MzMgYyAtMi4yNTUsMCAtNC4yODMsMC43ODM1IC01LjY3MSwyLjE4MDIgLTAuMTg1LDAuMTg3NCAtMC40NzEsMC4xNzAzIC0wLjYzOSwtMC4wMjU1IC0xLjE4NywtMS4zODgyIC0zLjAwNCwtMi4xNTQ3IC01LjE5MiwtMi4xNTQ3IC0yLjAxLDAgLTMuNzI3LDAuNjA0NyAtNC45MDUsMS43MjAzIHYgLTAuODY4NiBjIDAsLTAuMzgzMyAtMC4zMTEsLTAuNjk4NCAtMC42ODksLTAuNjk4NCBoIC0yLjM4MSBjIC0wLjM3OSwwIC0wLjY5LDAuMzE1MSAtMC42OSwwLjY5ODQgdiAxNS41NTk0IGMgMCwwLjM4MzIgMC4zMTEsMC42OTgzIDAuNjksMC42OTgzIGggMi40OTggYyAwLjM3OSwwIDAuNjksLTAuMzE1MSAwLjY5LC0wLjY5ODMgdiAtOC4wMTM5IGMgMCwtMy4wMjMzIDEuNTMxLC00Ljc2MDcgNC4xOTksLTQuNzYwNyAyLjM0NywwIDMuNTQyLDEuMzg4MiAzLjU0Miw0LjEzMDUgdiA4LjY0NDEgYyAwLDAuMzgzMiAwLjMxMSwwLjY5ODMgMC42OSwwLjY5ODMgaCAyLjQ5OCBjIDAuMzc5LDAgMC42OSwtMC4zMTUxIDAuNjksLTAuNjk4MyB2IC04LjAxMzkgYyAwLC0zLjAyMzMgMS41MzEsLTQuNzYwNyA0LjE5OSwtNC43NjA3IDIuMzU1LDAgMy41NDIsMS4zODgyIDMuNTQyLDQuMTMwNSB2IDguNjQ0MSBjIDAsMC4zODMyIDAuMzExLDAuNjk4MyAwLjY5LDAuNjk4MyBoIDIuNDk4IGMgMC4zNzksMCAwLjY5LC0wLjMxNTEgMC42OSwtMC42OTgzIHYgLTguOTc2MyBjIDAsLTQuNzE4IC0yLjUzMiwtNy40MjYyIC02Ljk0OSwtNy40MjYyIHogbSAxNDguNzE2LDE2LjM5NCAtNi44NDksLTguNzk3NCBjIC0wLjEzNCwtMC4xNzg4IC0wLjExNywtMC40MjU4IDAuMDM0LC0wLjU3OTEgbCA2LjE1LC02LjEyMzIgYyAwLjI3OCwtMC4yNzI2IDAuMDg1LC0wLjc0OTUgLTAuMzAyLC0wLjc0OTUgaCAtMy41ODUgYyAtMC4xNzYsMCAtMC4zMzYsMC4wNjgxIC0wLjQ2MiwwLjE4NzQgbCAtNi45MzMsNi40MzgzIGMgLTAuMjc4LDAuMjU1NSAtMC43MjQsMC4wNTk3IC0wLjcyNCwtMC4zMjM2IHYgLTUuNjAzNyBjIDAsLTAuMzgzMyAtMC4zMTEsLTAuNjk4NCAtMC42OSwtMC42OTg0IGggLTIuNDk4IGMgLTAuMzc5LDAgLTAuNjksMC4zMTUxIC0wLjY5LDAuNjk4NCB2IDE1LjU1OTMgYyAwLDAuMzgzMyAwLjMxMSwwLjY5ODQgMC42OSwwLjY5ODQgaCAyLjQ5OCBjIDAuMzg4LDAgMC42OSwtMC4zMTUxIDAuNjksLTAuNzA2OSBsIC0wLjAyNSwtMy42MTA5IGMgMCwtMC4xOTU5IDAuMDc2LC0wLjM4MzIgMC4yMTksLTAuNTE5NSBsIDIuMTU0LC0yLjAyNjkgYyAwLjE4NSwtMC4xNzAzIDAuNDcxLC0wLjE1MzMgMC42MzEsMC4wNTExIGwgNS4yMDgsNi41NDkxIGMgMC4xMzQsMC4xNjE4IDAuMzI4LDAuMjY0IDAuNTM4LDAuMjY0IGggMy41OTMgYyAwLjM2MSwwIDAuNTYzLC0wLjQxNzMgMC4zMzYsLTAuNzA2OSB6IgogICAgIGZpbGw9IiMwZTBlMTAiCiAgICAgaWQ9InBhdGgxODI0IgogICAgIGNsaXAtcGF0aD0ibm9uZSIgLz4KICA8cGF0aAogICAgIGQ9Im0gMTExLjE2NTE5LDExLjc4MDI1NCBjIDAsLTEuNTA3NCAtMC44MDgsLTIuODk1NTYwNSAtMi4xMDQsLTMuNjI3OTcwNSBsIC0xMy40ODY1OTksLTcuNjIyMTQgYyAtMS4yNDUyLC0wLjcwNjg1OCAtMi43NTk2LC0wLjcwNjg1OCAtNC4wMDQ4LDAgbCAtMTMuNDk1Miw3LjYyMjE0IGMgLTEuMjk1NywwLjczMjQxIC0yLjEwMzQsMi4xMjA1NzA1IC0yLjEwMzQsMy42Mjc5NzA1IHYgMTQuNTQ2IGMgMCwxLjUxNTkgMC44MTYxLDIuOTEyNSAyLjEyODYsMy42NDQ5IGwgMTMuNDk1Miw3LjUxMTUgYyAxLjIyODQsMC42ODk4IDIuNzI2LDAuNjg5OCAzLjk1NDMsMCBsIDEzLjQ5NDg5OSwtNy41MTE1IGMgMS4zMTMsLTAuNzMyNCAyLjEyOSwtMi4xMjkgMi4xMjksLTMuNjQ0OSB2IC0xNC41NDYgeiBtIC0yNS4wNzI1OTksMTQuNDM1MiBjIDAsMC4zNDA3IC0wLjM2MTgsMC41NTM2IC0wLjY1NjMsMC4zOTE4IGwgLTIuMjU0OCwtMS4yNjA0IGMgLTAuNDcxMSwtMC4yNjQgLTAuNzU3MiwtMC43NTggLTAuNzU3MiwtMS4zMDMgdiAtNi44NzI3IGMgMCwtMC4zNDA3IDAuMzYxOCwtMC41NTM2IDAuNjU2MywtMC4zOTE4IGwgMi40ODE5LDEuMzg4MiBjIDAuMzI4MiwwLjE3ODggMC41MzAxLDAuNTI4IDAuNTMwMSwwLjkxMTIgeiBtIDE4LjYyNzU5OSwtMi4yMDU3IGMgMCwwLjUzNjUgLTAuMjg2LDEuMDM5IC0wLjc1NywxLjMwMyBsIC0yLjI1NSwxLjI2MDQgYyAtMC4yOTUsMC4xNjE4IC0wLjY1NiwtMC4wNTExIC0wLjY1NiwtMC4zOTE3IHYgLTguNzg4OSBjIDAsLTAuMzQwNyAtMC4zNjIsLTAuNTUzNiAtMC42NTcsLTAuMzkxOCBsIC00LjE2NDM5OSwyLjMyNSBjIC0wLjQ3MTEsMC4yNjQgLTAuNzU3MiwwLjc1OCAtMC43NTcyLDEuMzAzIHYgOC45ODQ4IGMgMCwwLjI3MjUgLTAuMTQzLDAuNTE5NSAtMC4zNzg2LDAuNjQ3MiBsIC0wLjg0OTgsMC40NzY5IGMgLTAuNDM3NSwwLjI0NyAtMC45NzU5LDAuMjQ3IC0xLjQyMTgsMCBsIC0wLjc5MDksLTAuNDQyOCBjIC0wLjIzNTYsLTAuMTI3OCAtMC4zNzg2LC0wLjM4MzMgLTAuMzc4NiwtMC42NDczIHYgLTkuMDc4NCBjIDAsLTAuNTM2NSAtMC4yODYxLC0xLjAzOSAtMC43NTcyLC0xLjMwMyBsIC04LjI1MzYsLTQuNjE1OSBjIC0wLjE0MzEsLTAuMDc2NiAtMC4yMjcyLC0wLjIyOTkgLTAuMjI3MiwtMC4zOTE3IHYgLTAuMzU3NyBjIDAsLTAuNTM2NiAwLjI4NjEsLTEuMDM5IDAuNzU3MiwtMS4zMDMgbCAxLjE3NzksLTAuNjU1OCBjIDAuNDM3NSwtMC4yNDcgMC45NzYsLTAuMjQ3IDEuNDIxOSwwIGwgNy4xMzQ2LDMuOTk0MiBjIDAuNDM3NSwwLjI0NyAwLjk3NiwwLjI0NyAxLjQyMTksMCBsIDMuMjA1NSwtMS43OTcgYyAwLjMwMjksLTAuMTcwMyAwLjMwMjksLTAuNjEzMSAwLC0wLjc4MzUgbCAtNy4xNTk4LC00LjAwMjY2MDUgYyAtMC4zMDI5LC0wLjE3MDMzIC0wLjMwMjksLTAuNjEzMTggMCwtMC43ODM1IGwgMi40Mzk5LC0xLjM2MjYyIGMgMC40Mzc1LC0wLjI0Njk4IDAuOTc1OSwtMC4yNDY5OCAxLjQyMTgsMCBsIDkuNzE3Mzk5LDUuNDMzNDgwNSBjIDAuNDcxLDAuMjY0IDAuNzU3LDAuNzU3OSAwLjc1NywxLjMwMyB2IDEwLjA1NzggeiIKICAgICBmaWxsPSIjMGUwZTEwIgogICAgIGlkPSJwYXRoMTgyNiIKICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxOTUzKSIgLz4KPC9zdmc+Cg=="
  
  if pageIndex == 1 then
    -- Setup
    table.insert(graphics,{Type = "Svg", Image = made_logo, Position = {23, 12}, Size = {294,38}, ZOrder = zOerders.front, })
    local dLabels = {
      text = {"IP Address","API Username","API Password","Core Port Number","System Name","Model","Serial Number","Firmware Version","Uptime"},
      pos = {{10,97},{10,117},{10,137},{10,157},{10,216},{10,236},{10,256},{10,276},{10,296},}
    }
    for i=1, #dLabels.text do
      table.insert(graphics,{Type = "Text",Text = dLabels.text[i],Position = dLabels.pos[i],Color = Colors.Black, Size = labels.size, FontSize = 12, Font ="Roboto", HTextAlign = "Right", ZOrder = zOerders.labels})
    end
    table.insert(graphics,{Type = "Text", Text = "Connection Setup", Position = {5,67}, Color = Colors.Black, Size = {200,22}, FontSize = 18, Font ="Roboto", FontStyle = "Bold", HTextAlign = "Left", ZOrder = zOerders.labels})
    table.insert(graphics,{Type = "Text", Text = "Device Information", Position = {5,186}, Color = Colors.Black, Size = {200,22}, FontSize = 18, Font ="Roboto", FontStyle = "Bold", HTextAlign = "Left", ZOrder = zOerders.labels})
    table.insert(graphics,{Type = "Text", Text = "Connection Status", Position = {5,326}, Color = Colors.Black, Size = {200,22}, FontSize = 18, Font ="Roboto", FontStyle = "Bold", HTextAlign = "Left", ZOrder = zOerders.labels})
    table.insert(graphics,{Type = "Text", Text = "Version ".. PluginInfo.Version, Position = {260,388}, Color = Colors.Black, Size = {76,8}, FontSize = 9, Font ="Roboto", HTextAlign = "Right", ZOrder = zOerders.labels})
    table.insert(graphics,{Type = "GroupBox", Fill = Colors.White, CornerRadius = 0, StrokeWidth = 0, Position = {0,0}, Size = {340,404}, ZOrder = zOerders.back,})
    table.insert(graphics,{Type = "GroupBox", Fill = Colors.Background, CornerRadius = 0, StrokeWidth = 0, Position = {0,0}, Size = {340,62}, ZOrder = zOerders.zero,})
    table.insert(graphics,{Type = "GroupBox", Fill = Colors.Background, CornerRadius = 0, StrokeWidth = 0, Position = {4,89}, Size = {332,93}, ZOrder = zOerders.zero,})
    table.insert(graphics,{Type = "GroupBox", Fill = Colors.Background, CornerRadius = 0, StrokeWidth = 0, Position = {4,208}, Size = {332,114}, ZOrder = zOerders.zero,})
    table.insert(graphics,{Type = "GroupBox", Fill = Colors.Background, CornerRadius = 0, StrokeWidth = 0, Position = {4,348}, Size = {332,48}, ZOrder = zOerders.zero,})
    layout["IPAddress"] = {PrettyName = "Setup~IP Address", Style = "TextBox", Position = {145,97}, Size = clabels.size, FontSize = 12, StrokeWidth = 1, HTextAlign = "Center", ZOrder = zOerders.ctrl }
    layout["APIUsername"] = {PrettyName = "Setup~API User Name", Style = "TextBox", Position = {145,117}, Size = clabels.size, FontSize = 12, StrokeWidth = 1, HTextAlign = "Center", ZOrder = zOerders.ctrl }
    layout["APIPassword"] = {PrettyName = "Setup~API Password", Style = "TextBox", Position = {145,137}, Size = clabels.size, FontSize = 12, StrokeWidth = 1, HTextAlign = "Center", ZOrder = zOerders.ctrl }
    layout["InterfaceToCore"] = {PrettyName = "Setup~Interface To Core", Style = "ComboBox", Position = {145,157}, Size = clabels.size, FontSize = 12, StrokeWidth = 1, HTextAlign = "Center", ZOrder = zOerders.ctrl }
  
    layout["SystemName"] = {PrettyName = "Device Information~System Name", Style = "TextBox", Position = {145,216}, Size = clabels.size, FontSize = 12, Color = Colors.LightGray, StrokeWidth = 1, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl }
    layout["Model"] = {PrettyName = "Device Information~Model", Style = "TextBox", Position = {145,236}, Size = clabels.size, FontSize = 12, Color = Colors.LightGray, StrokeWidth = 1, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl }
    layout["SerialNumber"] = {PrettyName = "Device Information~Serial Number", Style = "TextBox", Position = {145,256}, Size = clabels.size, FontSize = 12, Color = Colors.LightGray, StrokeWidth = 1, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl }
    layout["FirmwareVersion"] = {PrettyName = "Device Information~Firmware Version", Style = "TextBox", Position = {145,276}, Size = clabels.size, FontSize = 12, Color = Colors.LightGray, StrokeWidth = 1, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl }
    layout["Uptime"] = {PrettyName = "Device Information~Uptime", Style = "TextBox", Position = {145,296}, Size = clabels.size, FontSize = 12, Color = Colors.LightGray, StrokeWidth = 1, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl }
    layout["Status"] = {PrettyName = "Connection Status~Status", Style = "TextBox", Position = {9,356}, Size = {321,32}, FontSize = 12, StrokeWidth = 1, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl }
    layout["Reboot"] = {PrettyName = "Connection Status~Reboot", Style = "Button", ButtonStyle = "Trigger", Position = {280,326}, Size = btns.size, Color = Colors.White, UnlinkOffColor = true, OffColor = {242,137,174}, CornerRadius = 2, Margin = 0, Padding = 0, StrokeWidth = 1, FontSize = 9, Legend = "Reboot", ZOrder = zOerders.ctrl }
  
  elseif pageIndex >= firstIntPg and pageIndex <= lastIntPg then
    local blabels = {
      text = {"Port","En/Disable","Interface","Comment","Running","Link Speed","En/Disable","Mode","State"},
      pos = {{10,95},{10,115},{10,135},{10,155},{10,175},{10,195},{10,235},{10,255},{10,275},}
    }
    for i=1, #blabels.text do
      table.insert(graphics,{Type = "Text",Text = blabels.text[i],Position = blabels.pos[i],Color = Colors.Black, Size = labels.size2, FontSize = 12, Font ="Roboto", HTextAlign = "Right", ZOrder = zOerders.labels})
    end
    if props["Port Information"].Value == "Basic+PoE" or props["Port Information"].Value == "Basic+PoE+Packets" then
      local elabels = {
        text = {"En/Disable","Mode","State","Out Status","Out Power","Out Voltage","Out Ampere"},
        pos = {{10,235},{10,255},{10,275},{10,295},{10,315},{10,335},{10,355},}
      }
      for i=1, #elabels.text do
        table.insert(graphics,{Type = "Text",Text = elabels.text[i],Position = elabels.pos[i],Color = Colors.Black, Size = labels.size2, FontSize = 12, Font ="Roboto", HTextAlign = "Right", ZOrder = zOerders.labels})
      end
    end
    if props["Port Information"].Value == "Basic+PoE+Packets" then
      local vlabels = {
        text = {"Bytes","Unicast Pkts","Multicast Pkts","Broadcast Pkts","Error Event",
        "Bytes","Unicast Pkts","Multicast Pkts","Broadcast Pkts","Dropped Pkts", "Device's MAC"},
        pos = {{10,395},{10,415},{10,435},{10,455},{10,475},
        {10,515},{10,535},{10,555},{10,575},{10,595},{10,620},}
      }
      for i=1, #vlabels.text do
        table.insert(graphics,{Type = "Text",Text = vlabels.text[i],Position = vlabels.pos[i],Color = Colors.Black, Size = labels.size2, FontSize = 12, Font ="Roboto", HTextAlign = "Right", ZOrder = zOerders.labels})
      end
    end
    local i        = pageIndex - firstIntPg + 1
    local startIf  = (i - 1) * perPage + 1
    local endIf    = math.min(i * perPage, maxIf)
    local PageName = string.format("Interfaces %d-%d", startIf, endIf)
    local maxwide = 1720
    local numInterfacesOnPage = endIf - startIf + 1
    local minport = 2
    function calcWidth(baseWidth)
      local calculated = baseWidth + math.max(0, numInterfacesOnPage - minport) * 100
      local finalWidth = math.min(calculated, maxwide)
      return finalWidth
    end
    function calcLogoWidth(baseWidth)
      local calculated = baseWidth + math.max(0, numInterfacesOnPage - minport) * 100
      local finalWidth = math.min(calculated, calcWidth(195)/2 -30 )
      return finalWidth
    end
  
    local interfaceBoxWidth = calcWidth(195) or 195
    -- Interface Header
    table.insert(graphics,{Type = "Header", Text = PageName, Position = {110,60}, Size = {interfaceBoxWidth, 30}, FontSize = 18, Font ="Roboto", FontStyle = "Bold", HTextAlign = "Center", Color = Colors.Black, ZOrder = zOerders.labels,})
    -- PoE Header
    table.insert(graphics,{Type = "Header", Text = "PoE", Position = {110,215}, Size = {interfaceBoxWidth, 20}, FontSize = 12, HTextAlign = "Center", Color = Colors.Black, ZOrder = zOerders.labels,})
    if props["Port Information"].Value=="Basic+PoE+Packets" then
      -- Receive Header
      table.insert(graphics,{Type = "Header", Text = "Receive", Position = {110,375}, Size = {interfaceBoxWidth, 20}, FontSize = 12, HTextAlign = "Center", Color = Colors.Black, ZOrder = zOerders.labels,})
      -- Transmit Header
      table.insert(graphics,{Type = "Header", Text = "Transmit", Position = {110,495}, Size = {interfaceBoxWidth, 20}, FontSize = 12, HTextAlign = "Center", Color = Colors.Black, ZOrder = zOerders.labels,})
    end
    local logoPos = calcLogoWidth(10) or 10
    table.insert(graphics,{Type = "Svg", Image = made_logo, Position = {logoPos, 12}, Size = {294,38}, ZOrder = zOerders.front, })
    local groupBoxWidth = calcWidth(315) or 315
    table.insert(graphics,{Type = "GroupBox", Fill = Colors.Background, CornerRadius = 0, StrokeWidth = 0, Position = {0,0}, Size = {groupBoxWidth, 60}, ZOrder = zOerders.back,})
    local groupGrayWidth = calcWidth(305) or 305
    local groupGrayHeight = props["Port Information"].Value=="Basic+PoE" and 285 or props["Port Information"].Value=="Basic+PoE+Packets" and 550 or 215 -- 530
    table.insert(graphics,{Type = "GroupBox", Fill = Colors.Background, CornerRadius = 0, StrokeWidth = 0, Position = {5,90}, Size = {groupGrayWidth, groupGrayHeight}, ZOrder = zOerders.back,})
    local group2GrayWidth = calcWidth(315) or 315
    local groupWhiteHeight = props["Port Information"].Value=="Basic+PoE" and 380 or props["Port Information"].Value=="Basic+PoE+Packets" and 645 or 310 -- 625
    table.insert(graphics,{Type = "GroupBox", Fill = Colors.White, CornerRadius = 0, StrokeWidth = 0, Position = {0,0}, Size = {group2GrayWidth, groupWhiteHeight}, ZOrder = zOerders.back,})
  
    local perPage = 16
    local cellW   = 100
  
    for idx = startIf, endIf do
      local col = idx - startIf
      local x   = col * cellW
      -- Enable
      layout[string.format("PortLabel %d", idx)] = { PrettyName = string.format("%s~Port~Port %d", PageName, idx), Style = "TextBox", Position = { x + 110, 95 }, Color = Colors.White0, Size = labels.size2, StrokeWidth = 0, Margin = 2, FontSize = 12, HTextAlign  = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
      layout[string.format("Enable/Disable Port %d", idx)] = { PrettyName = string.format("%s~Enable~Enable %d", PageName, idx), Style = "Button", ButtonStyle  = "Toggle", Position = { x + 140, 115 }, Size = btns.size2, Cornaradius = 3, StrokeWidth = 1, Color = {16,16,255}, UnlinkOffColor = true, OffColor = {124,124,124}, ZOrder = zOerders.ctrl,}
      layout[string.format("Interface %d", idx)] = { PrettyName = string.format("%s~Interface~Interface %d", PageName, idx), Style = "TextBox", Position = { x + 110, 135 }, Color = Colors.White0, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
      layout[string.format("Comment %d", idx)] = { PrettyName = string.format("%s~Comment~Comment %d", PageName, idx), Style = "TextBox", Position = { x + 110, 155 }, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", ZOrder = zOerders.ctrl,}
      layout[string.format("Running %d", idx)] = { PrettyName = string.format("%s~Running~Running %d", PageName, idx), Style = "LED", Position = { x + 150, 175 }, Size = leds.size, Margin = 2, Color = Colors.Blue, ZOrder = zOerders.ctrl,}
      layout[string.format("LinkSpeed %d", idx)] = { PrettyName = string.format("%s~LinkSpeed~LinkSpeed %d", PageName, idx), Style = "TextBox", Position = { x + 110, 195 }, Color = Colors.White0, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
      -- PoE Enable
      layout[string.format("Enable/Disable PoE %d", idx)] = { PrettyName = string.format("%s~PoE Enable~PoE Enable %d", PageName, idx), Style = "Button", ButtonStyle  = "Toggle", Position = { x + 140, 235 }, Size = btns.size2, Cornaradius = 3, StrokeWidth = 1, Color = {0,255,0}, UnlinkOffColor = true, OffColor = {124,124,124}, ZOrder = zOerders.ctrl,}
      layout[string.format("PoeMode %d", idx)] = { PrettyName = string.format("%s~PoE Mode~PoE Mode %d", PageName, idx), Style = "TextBox", Position = { x + 110, 255 }, Color = Colors.LightYellow, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
      layout[string.format("PoeStatus %d", idx)] = { PrettyName = string.format("%s~PoE State~PoE State %d", PageName, idx), Style = "LED", Position = { x + 150, 275 }, Size = leds.size, Margin = 2, Color = Colors.OnlineGreen, ZOrder = zOerders.ctrl,}
  
      if props["Port Information"].Value == "Basic+PoE" or props["Port Information"].Value == "Basic+PoE+Packets" then
        layout[string.format("PoeOutStatus %d", idx)] = { PrettyName = string.format("%s~PoE Out Status~PoE Out Status %d", PageName, idx), Style = "TextBox", Position = { x + 110, 295 }, Color = Colors.LightYellow, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
        layout[string.format("PoeOutPower %d", idx)] = { PrettyName = string.format("%s~PoE Out Power~PoE Out Power %d", PageName, idx), Style = "TextBox", Position = { x + 110, 315 }, Color = Colors.LightYellow, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
        layout[string.format("PoeOutVoltage %d", idx)] = { PrettyName = string.format("%s~PoE Out Voltage~PoE Out Voltage %d", PageName, idx), Style = "TextBox", Position = { x + 110, 335 }, Color = Colors.LightYellow, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
        layout[string.format("PoeOutCurrent %d", idx)] = { PrettyName = string.format("%s~PoE Out Current Ampere~PoE Out Current Ampere %d", PageName, idx), Style = "TextBox", Position = { x + 110, 355 }, Color = Colors.LightYellow, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
      end
      if props["Port Information"].Value == "Basic+PoE+Packets" then
        layout[string.format("ReceivedByte %d", idx)] = { PrettyName = string.format("%s~Received~Received Byte %d", PageName, idx), Style = "TextBox", Position = { x + 110, 395 }, Color = Colors.Orange, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
        layout[string.format("ReceivedUnicast %d", idx)] = { PrettyName = string.format("%s~Received~Received Unicast %d", PageName, idx), Style = "TextBox", Position = { x + 110, 415 }, Color = Colors.Orange, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
        layout[string.format("ReceivedMulticast %d", idx)] = { PrettyName = string.format("%s~Received~Received Multicast %d", PageName, idx), Style = "TextBox", Position = { x + 110, 435 }, Color = Colors.Orange, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
        layout[string.format("ReceivedBroadcast %d", idx)] = { PrettyName = string.format("%s~Received~Received Broadcast %d", PageName, idx), Style = "TextBox", Position = { x + 110, 455 }, Color = Colors.Orange, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
        layout[string.format("ReceivedError %d", idx)] = { PrettyName = string.format("%s~Received~Received Error %d", PageName, idx), Style = "TextBox", Position = { x + 110, 475 }, Color = Colors.Orange, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
  
        layout[string.format("TransmittedByte %d", idx)] = { PrettyName = string.format("%s~Transmitted~Transmitted Byte %d", PageName, idx), Style = "TextBox", Position = { x + 110, 515 }, Color = Colors.LightBlue, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
        layout[string.format("TransmittedUnicast %d", idx)] = { PrettyName = string.format("%s~Transmitted~Transmitted Unicast %d", PageName, idx), Style = "TextBox", Position = { x + 110, 535 }, Color = Colors.LightBlue, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
        layout[string.format("TransmittedMulticast %d", idx)] = { PrettyName = string.format("%s~Transmitted~Transmitted Multicast %d", PageName, idx), Style = "TextBox", Position = { x + 110, 555 }, Color = Colors.LightBlue, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
        layout[string.format("TransmittedBroadcast %d", idx)] = { PrettyName = string.format("%s~Transmitted~Transmitted Broadcast %d", PageName, idx), Style = "TextBox", Position = { x + 110, 575 }, Color = Colors.LightBlue, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
        layout[string.format("TransmittedDropped %d", idx)] = { PrettyName = string.format("%s~Transmitted~Transmitted Dropped %d", PageName, idx), Style = "TextBox", Position = { x + 110, 595 }, Color = Colors.LightBlue, Size = labels.size2, Margin = 2, FontSize = 12, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
  
        layout[string.format("DeviceMAC %d", idx)] = { PrettyName = string.format("%s~Device's MAC~Device's MAC Address %d", PageName, idx), Style = "TextBox", Position = { x + 110, 620 }, Color = Colors.LightGray, Size = labels.size2, Margin = 2, FontSize = 11, HTextAlign = "Center", IsReadOnly = true, ZOrder = zOerders.ctrl,}
      end
    end
  
  elseif pageIndex == eventPg then
    -- Event Log
    table.insert(graphics,{Type = "Svg", Image = made_logo, Position = {103, 12}, Size = {294,38}, ZOrder = zOerders.front, })
  
    table.insert(graphics,{Type = "Text", Text = "Event Log", Position = {5,67}, Color = Colors.Black, Size = {200,22}, FontSize = 18, Font ="Roboto", FontStyle = "Bold", HTextAlign = "Left", ZOrder = zOerders.labels})
    table.insert(graphics,{Type = "GroupBox", Fill = Colors.Background, CornerRadius = 0, StrokeWidth = 0, Position = {0,0}, Size = {500,62}, ZOrder = zOerders.back,})
    table.insert(graphics,{Type = "GroupBox", Fill = Colors.Background, CornerRadius = 0, StrokeWidth = 0, Position = {4,90}, Size = {492,566}, ZOrder = zOerders.back,})
    table.insert(graphics,{Type = "GroupBox", Fill = Colors.White, CornerRadius = 0, StrokeWidth = 0, Position = {0,0}, Size = {500,683}, ZOrder = zOerders.back,})
  
    layout["LogMsg"] = {PrettyName = "Event Log~Log Message", Style = "ListBox", Position = {10,115}, Size = {480,513}, FontSize = 9, StrokeWidth = 1, HTextAlign = "Left", VTextAlign = "Top", ZOrder = zOerders.ctrl }
  
    layout["GetLog"] = {PrettyName = "Event Log~Get Log", Style = "Button", ButtonStyle = "Trigger", Position = {220,93}, Size = btns.size, CornerRadius = 2, Margin = 0, Padding = 0, StrokeWidth = 1, FontSize = 9, Legend = "Get", ZOrder = zOerders.ctrl }
    layout["LogClear"] = {PrettyName = "Event Log~Clear", Style = "Button", ButtonStyle = "Trigger", Position = {440,93}, Size = btns.size, CornerRadius = 2, Margin = 0, Padding = 0, StrokeWidth = 1, FontSize = 9, Legend = "Clear", ZOrder = zOerders.ctrl }
  
  elseif props["Enable SSH Terminal"].Value and pageIndex == sshPg then
    -- SSH Terminal
    table.insert(graphics,{Type = "Svg", Image = made_logo, Position = {103, 12}, Size = {294,38}, ZOrder = zOerders.front, })
    local sLabels = {
      text = {"SSH Username","SSH Password","Discconnet Time","(seconds)",},
      pos = {{139,67},{140,85},{140,103},{350,103},},
      size = {labels.size,labels.size,labels.size,{50,18}}
    }
    for i=1, #sLabels.text do
      table.insert(graphics,{Type = "Text",Text = sLabels.text[i],Position = sLabels.pos[i],Color = Colors.Black, Size = sLabels.size[i], FontSize = sLabels.text[i]=="(seconds)" and 10 or 12, Font ="Roboto", HTextAlign = sLabels.text[i]=="(seconds)" and "Left" or "Right", ZOrder = zOerders.labels})
    end
    table.insert(graphics,{Type = "Text", Text = utf8.char(0x3E), Position = {10,649}, StrokeWidth = 0, Size = {18,18}, FontSize = 18, Font ="Roboto", FontStyle = "Bold", HTextAlign = "Left", ZOrder = zOerders.labels})
  
    table.insert(graphics,{Type = "Text", Text = "SSH Terminal", Position = {5,67}, Color = Colors.Black, Size = {200,22}, FontSize = 18, Font ="Roboto", FontStyle = "Bold", HTextAlign = "Left", ZOrder = zOerders.labels})
    table.insert(graphics,{Type = "GroupBox", Fill = Colors.Background, CornerRadius = 0, StrokeWidth = 0, Position = {0,0}, Size = {500,62}, ZOrder = zOerders.back,})
    table.insert(graphics,{Type = "GroupBox", Fill = Colors.Background, CornerRadius = 0, StrokeWidth = 0, Position = {4,124}, Size = {492,553}, ZOrder = zOerders.back,})
    table.insert(graphics,{Type = "GroupBox", Fill = Colors.White, CornerRadius = 0, StrokeWidth = 0, Position = {0,0}, Size = {500,683}, ZOrder = zOerders.back,})
  
    layout["SSHUsername"] = {PrettyName = "SSH Terminal~SSH User Name", Style = "TextBox", Position = {275,67}, Size = clabels.size, FontSize = 12, StrokeWidth = 1, HTextAlign = "Center", ZOrder = zOerders.ctrl }
    layout["SSHPassword"] = {PrettyName = "SSH Terminal~SSH Password", Style = "TextBox", Position = {275,85}, Size = clabels.size, FontSize = 12, StrokeWidth = 1, HTextAlign = "Center", ZOrder = zOerders.ctrl }
    layout["SSHTimeOut"] = {PrettyName = "SSH Terminal~TimeOut Time", Style = "TextBox", Position = {275,103}, Color = {110,198,241}, Size = {75,18}, FontSize = 12, StrokeWidth = 1, HTextAlign = "Center", ZOrder = zOerders.ctrl }
    layout["SSHTimeOutDisplay"] = {PrettyName = "SSH Terminal~TimeOut Remain Display", Style = "TextBox", Position = {424,103}, Color = Colors.LightGray, Size = {36,16}, FontSize = 9, StrokeWidth = 1, HTextAlign = "Center", ZOrder = zOerders.ctrl }
    layout["SSHConnected"] = { PrettyName = "SSH Terminal~Connected", Style = "LED", Position = {10,131}, Size = {12,12}, Color = Colors.Blue, Margin = 0, Padding = 0, StrokeWidth = 0, ZOrder = zOerders.ctrl}
    layout["SSHOutput"] = {PrettyName = "SSH Terminal~Debug Message", Style = "TextBox", Position = {10,149}, Size = {480,500}, FontSize = 12, Padding = 5, StrokeWidth = 1, HTextAlign = "Left", VTextAlign = "Top", ZOrder = zOerders.ctrl }
    layout["SSHInput"] = {PrettyName = "SSH Terminal~Command Input", Style = "TextBox", Position = {25,649}, Size = {425,18}, FontSize = 12, Padding = 0, StrokeWidth = 1, HTextAlign = "Left", VTextAlign = "Center", ZOrder = zOerders.ctrl }
  
    layout["SSHConnect"] = {PrettyName = "SSH Terminal~Connect", Style = "Button", ButtonStyle = "Trigger", Position = {26,127}, Size = btns.size, CornerRadius = 2, Margin = 0, Padding = 0, StrokeWidth = 1, FontSize = 9, Legend = "Connect", ZOrder = zOerders.ctrl }
    layout["SSHDisconnect"] = {PrettyName = "SSH Terminal~Disconnect", Style = "Button", ButtonStyle = "Trigger", Position = {220,127}, Size = btns.size, CornerRadius = 2, Margin = 0, Padding = 0, StrokeWidth = 1, FontSize = 9, Legend = "Disconnect", ZOrder = zOerders.ctrl }
    layout["SSHClear"] = {PrettyName = "SSH Terminal~Clear", Style = "Button", ButtonStyle = "Trigger", Position = {440,127}, Size = btns.size, CornerRadius = 2, Margin = 0, Padding = 0, StrokeWidth = 1, FontSize = 9, Legend = "Clear", ZOrder = zOerders.ctrl }
    layout["SSHSend"] = {PrettyName = "SSH Terminal~Send", Style = "Button", ButtonStyle = "Trigger", Position = {450,649}, Size = {40,18}, CornerRadius = 0, Margin = 0, Padding = 0, StrokeWidth = 1, FontSize = 9, ZOrder = zOerders.ctrl }
  
  end
  return layout, graphics
end

--Start event based logic
if Controls then
  -- ** Debug Print **--
  DebugTx=false
  DebugRx=false
  DebugFunc=false
  DebugPrint=Properties["Debug Print"].Value
  -- A function to determine common print statement scenarios for troubleshooting
  function SetupDebugPrint()
    if     DebugPrint=="Tx/Rx"    then DebugTx,DebugRx=true,true
    elseif DebugPrint=="Tx"       then DebugTx=true
    elseif DebugPrint=="Rx"       then DebugRx=true
    elseif DebugPrint=="Function" then DebugFunc=true
    elseif DebugPrint=="All"      then DebugTx,DebugRx,DebugFunc=true,true,true
    end
  end
  SetupDebugPrint()
  
  -- Variables
  local status = Controls["Status"]
  status.Value = 5
  local port = Properties["Connection Type"].Value == "TCP" and 8728 or 8729 -- 8729
  local sshport = 22
  local state = "init"
  local nextTagId = 0
  local tagCallbacks = {}
  local tagRepliesAccum = {}
  local initLogin = false
  local hasInitVisibility = false
  local buffer = "" -- rx buffer
  local interfacesName, defaultName = {},{}
  local polltimer = Timer.New()
  -- Create TcpSocket
  local sock = Properties["Connection Type"].Value == "TCP" and TcpSocket.New() or TcpSocket.NewTls() -- Tls({ VerifyPeer = false })
  print("Connection Tyep: "..Properties["Connection Type"].Value)
  sock.ReadTimeout = 0
  sock.WriteTimeout = 0
  sock.ReconnectTimeout = 5
  -- Constants for reply types
  local REPLY_TYPES = { DONE = "!done", TRAP = "!trap", RE = "!re", EMPTY = "!empty", FATAL = "!fatal" }
  -- Set Commands table
  local COMMANDS = {
    INTERFACE = "/interface/ethernet/print", POE = "/interface/ethernet/poe/print", ALL = "/interface/getall"
  }
  -- mapping define
  local INTERFACE_MAPPING = {
    ["Interface"]            = "name", -- Port # → Interface
    ["Comment"]              = { attr = "comment", formatter = function(v) if v == "" or v == nil then return "" else return v end end, type = "String"},
    ["ReceivedByte"]         = { attr = "rx-bytes", formatter = function(v) return formatByte(v) end },
    ["ReceivedUnicast"]      = { attr = "rx-unicast", formatter = function(v) return formatCast(v) end },
    ["ReceivedMulticast"]    = { attr = "rx-multicast", formatter = function(v) return formatCast(v) end },
    ["ReceivedBroadcast"]    = { attr = "rx-broadcast", formatter = function(v) return formatCast(v) end },
    ["ReceivedError"]        = { attr = "rx-error-events", formatter = function(v) return formatCast(v) end },
    ["TransmittedByte"]      = { attr = "tx-bytes", formatter = function(v) return formatByte(v) end },
    ["TransmittedUnicast"]   = { attr = "tx-unicast", formatter = function(v) return formatCast(v) end },
    ["TransmittedMulticast"] = { attr = "tx-multicast", formatter = function(v) return formatCast(v) end },
    ["TransmittedBroadcast"] = { attr = "tx-broadcast", formatter = function(v) return formatCast(v) end },
    ["TransmittedDropped"]   = { attr = "tx-drop", formatter = function(v) return formatCast(v) end },
    -- ["DeviceMAC"]            = { attr = "mac-address", formatter = function(v) if v == "" or v == nil then return "" else return v end end, type = "String"},
    ["Running"]              = { attr = "running", formatter = function(v) return v == "true" and true or false end, type = "Boolean" },
    ["Enable/Disable Port"]  = { attr = "disabled", formatter = function(v) return v == "false" and true or false end, type = "Boolean" },
    ["PoeOut"]               = { attr = "poe-out", type = "String" },
    ["PoeVoltage"]           = { attr = "poe-voltage", formatter = function(v) return v or "0" end, type = "String" }, -- Assuming voltage is okay as string
    -- ["PoeStatus"] = { attr = "poe-out", formatter = function(v) return v == "powered-on" or v == "auto-on" or false end, type = "Boolean" },
    ["PoeMode"]              = { attr = "poe-out", formatter = function(v) return v or "N/A" end, type = "String" },
    --["Enable/Disable PoE"] = { attr = "poe-out", formatter = function(v) return v == "powered-on" or v == "auto-on" or false end, type = "Boolean" }
  }
  local IsInvisible_MAPPING = {
    "Interface", "Comment", "ReceivedByte", "ReceivedUnicast", "ReceivedMulticast", "ReceivedBroadcast","ReceivedError",
    "TransmittedByte", "TransmittedUnicast", "TransmittedMulticast", "TransmittedBroadcast","DeviceMAC",
    "TransmittedDropped", "LinkSpeed", "Mac", "Running", "Enable/Disable Port",
    "PoeOut", "PoeDraw", "PoeStatus", "PoeMode","PoeVoltage", "Enable/Disable PoE",
    "PoeOutStatus", "PoeOutVoltage", "PoeOutCurrent", "PoeOutPower",
  }
  local IsInvisible_PoE_MAPPING = {
    "PoeStatus","PoeMode","PoeVoltage","Enable/Disable PoE","PoeOutStatus","PoeOutVoltage","PoeOutCurrent","PoeOutPower",
  }
  
  Controls["SSHUsername"].String = "Every connection requires input"
  Controls["SSHPassword"].String = "Every connection requires input"
  -- Setup function
  function Setup()
    address = Controls["IPAddress"].String == "" and "Invalid IP Address" or Controls["IPAddress"].String
    Controls["IPAddress"].String = address
    user = Controls["APIUsername"].String
    pass = Controls["APIPassword"].String
    sshuser = Controls["SSHUsername"].String
    sshpass = Controls["RealSSHPass"].String
  end
  
  sock.ReadTimeout = 0
  sock.WriteTimeout = 0
  sock.ReconnectTimeout = 5
  
  -- Utility functions
  function parseWord(word)
    local _, equalsPos = string.find(word, '=')
    if not equalsPos then return "type", word end
    return word:sub(1, equalsPos - 1), word:sub(equalsPos + 1)
  end
  
  function encodeLength(len)
    local char = string.char
    if len < 0x80 then
      return char(len)
    elseif len < 0x4000 then
      return char(bit.bor(bit.rshift(len, 8), 0x80)) .. char(bit.band(len, 0xFF))
    elseif len < 0x200000 then
      return char(bit.bor(bit.rshift(len, 16), 0xC0)) ..
            char(bit.band(bit.rshift(len, 8), 0xFF)) .. char(bit.band(len, 0xFF))
    elseif len < 0x10000000 then
      return char(bit.bor(bit.rshift(len, 24), 0xE0)) ..
            char(bit.band(bit.rshift(len, 16), 0xFF)) ..
            char(bit.band(bit.rshift(len, 8), 0xFF)) .. char(bit.band(len, 0xFF))
    else
      return '\xF0' .. char(bit.band(bit.rshift(len, 24), 0xFF)) ..
            char(bit.band(bit.rshift(len, 16), 0xFF)) ..
            char(bit.band(bit.rshift(len, 8), 0xFF)) .. char(bit.band(len, 0xFF))
    end
  end
  
  function encodeWord(word) return encodeLength(string.len(word)) .. word end
  local MAX_TAG = 10000
  function nextTag() nextTagId = (nextTagId % MAX_TAG) + 1 return "Tag" .. nextTagId end
  
  --------------------------------------------
  -- Send functions
  --------------------------------------------
  function sendSentence(words, callback)
    local message = ""
    for _, word in ipairs(words) do message = message .. encodeWord(word) end
    -- Add tag if callback provided and no tag exists
    if callback then
      local hasTag = false
      for _, word in ipairs(words) do
        if word:sub(1, 5) == '.tag=' then hasTag = true; break end
      end
      if not hasTag then
        local tag = nextTag()
        message = message .. encodeWord('.tag=' .. tag)
        tagCallbacks[tag] = callback
      end
    end
    message = message .. string.char(0)
    if sock.IsConnected then
      sock:Write(message)
      if DebugTx then print("Sending: " .. table.concat(words, " ")) end
    end
  end
  
  -- Unified data extraction function for all response handlers
  function extractReplies(replies)
    local data = {}
    local hasErr, errMsg = false, nil
    for _, reply in ipairs(replies) do
      if reply.type == REPLY_TYPES.RE then
        local item = {}
        -- Iterate through the raw words of the reply sentence
        for _, word in ipairs(reply.raw) do
          -- Try to parse words like =key=value
          local key, value = word:match("^=([^=]+)=(.*)$")
          -- Add the key/value to the item table UNLESS it's the .tag
          if key and key ~= ".tag" then
            item[key] = value
          elseif word:match("^;;;") then
            item["comment"] = word:sub(4) -- Handle comments
          end
        end
        -- Add the populated item to the data list if it's not empty
        if next(item) then table.insert(data, item) end
      elseif reply.type == REPLY_TYPES.TRAP then
        -- Handle errors
        hasErr, errMsg = true, reply.parsed["=message"] or "Unknown error"
        break -- Stop processing replies for this tag if a trap occurs
      end
    end
  
    return data, hasErr, errMsg
  end
  
  function executeCommand(cmd, callback)
    local words = {}
    for word in string.gmatch(cmd, "%S+") do table.insert(words, word) end
    local wrappedCallback
    if callback then
      wrappedCallback = function(replies)
        local data, hasErr, errMsg = extractReplies(replies)
        callback(data, hasErr, errMsg, replies)
      end
    end
    sendSentence(words, wrappedCallback)
  end
  --------------------------------------------
  -- UI update function (now using the unified data extraction)
  --------------------------------------------
  function sortPort(data)
    table.sort(data, function(a, b)
      local nameA, nameB = a["default-name"], b["default-name"]
      -- Determine type priority
      local function portType(n)
        if n:find("ether") then return 1 end
        if n:find("sfp") then   return 2 end
        return 3
      end
      local ta, tb = portType(nameA), portType(nameB)
      if ta ~= tb then return ta < tb end
      -- Fallback: numeric comparison of trailing digits
      local na = tonumber(nameA:match("%d+$")) or math.huge
      local nb = tonumber(nameB:match("%d+$")) or math.huge
      if na ~= nb then return na < nb end
      -- Last fallback: lexicographical
      return nameA < nameB
    end)
  end
  
  function updateUI(command, mapping, isIndex)
    isIndex = isIndex or false
    executeCommand(command, function(data, hasErr, errMsg)
      if hasErr then if DebugTx then print("Error executing command '" .. command .. "':", errMsg) return end end
      sortPort(data)
      -- Populate interface list if needed
      if command == "/interface/ethernet/print" then
        local ifaceNames = {}
        for _, entry in ipairs(data) do table.insert(ifaceNames, entry.name) end
        Controls.InterfaceToCore.Choices = ifaceNames
      end
      local items = isIndex and data or {data[1] or {}}
      for index, info in ipairs(items) do
        for ctrlName, mapInfo in pairs(mapping) do
          local attr = type(mapInfo) == "table" and mapInfo.attr or mapInfo
          local formatter = type(mapInfo) == "table" and mapInfo.formatter or function(v) return v or "N/A" end
          local mapType = type(mapInfo) == "table" and mapInfo.type or "String"
          local value = formatter(info[attr])
          local ctrl = Controls[ctrlName]
          if ctrl then
            if isIndex and type(ctrl) == "table" and ctrl[index] then
              if mapType == "Boolean" then ctrl[index].Boolean = value
              else ctrl[index].String = value
              end
            elseif not isIndex then
              if mapType == "Boolean" then ctrl.Boolean = value
              else ctrl.String = value
              end
            end
          end
        end
      end
    end)
  end
  --------------------------------------------
  -- Buffer processing functions
  --------------------------------------------
  function readLenFromBuffer(pos)
    if pos > #buffer then return nil, pos end
    local lenByte = string.byte(buffer:sub(pos, pos))
    local len, bytesRead = nil, 1
    if lenByte < 0x80 then
      len = lenByte
    elseif lenByte < 0xC0 then
      if pos + 1 > #buffer then return nil, pos end
      len = ((lenByte & 0x7F) << 8) | string.byte(buffer, pos + 1)
      bytesRead = 2
    elseif lenByte < 0xE0 then
      if pos + 2 > #buffer then return nil, pos end
      len = ((lenByte & 0x3F) << 16) | (string.byte(buffer, pos + 1) << 8) |
            string.byte(buffer, pos + 2)
      bytesRead = 3
    elseif lenByte < 0xF0 then
      if pos + 3 > #buffer then return nil, pos end
      len = ((lenByte & 0x1F) << 24) | (string.byte(buffer, pos + 1) << 16) |
            (string.byte(buffer, pos + 2) << 8) | string.byte(buffer, pos + 3)
      bytesRead = 4
    elseif lenByte == 0xF0 then
      if pos + 4 > #buffer then return nil, pos end
      len = (string.byte(buffer, pos + 1) << 24) | (string.byte(buffer, pos + 2) << 16) |
            (string.byte(buffer, pos + 3) << 8) | string.byte(buffer, pos + 4)
      bytesRead = 5
    else
      if DebugRx then print("Warning: Unknown length byte: " .. lenByte)
      return nil, pos + 1 end
    end
    return len, pos + bytesRead
  end
  
  function processBuffer()
    local pos = 1
    while pos <= #buffer do
      local sentence = {}
      local parsed = {}
      local startPos = pos
  
      while true do
        local length, newPos = readLenFromBuffer(pos)
        if not length then buffer = buffer:sub(startPos) return end
        pos = newPos
  
        if length > 0 then
          if pos + length - 1 > #buffer then buffer = buffer:sub(startPos) return end
          local word = buffer:sub(pos, pos + length - 1)
          pos = pos + length
          table.insert(sentence, word)
          local attr, value = parseWord(word)
          parsed[attr] = value
        else break end
      end
  
      if #sentence > 0 then
        local replyType = parsed.type or "unknown"
        local typeLabels = {[REPLY_TYPES.RE] = "[DATA] ", [REPLY_TYPES.DONE] = "[DONE] ", [REPLY_TYPES.TRAP] = "[ERROR] ", [REPLY_TYPES.EMPTY] = "[EMPTY] ", [REPLY_TYPES.FATAL] = "[FATAL] ",}
        if DebugRx then print("\n" .. (typeLabels[replyType] or "[UNKNOWN] ") .. table.concat(sentence, "\n")) end
        local reply = { raw = sentence, parsed = parsed, type = replyType }
        local tag = parsed['.tag']
        if tag then
          if not tagRepliesAccum[tag] then tagRepliesAccum[tag] = {} end
          table.insert(tagRepliesAccum[tag], reply)
        end
        if replyType == REPLY_TYPES.DONE or replyType == REPLY_TYPES.TRAP or replyType == REPLY_TYPES.FATAL then
          if tag and tagCallbacks[tag] then
            local callback = tagCallbacks[tag]
            callback(tagRepliesAccum[tag])
            tagRepliesAccum[tag] = nil
            tagCallbacks[tag] = nil
          end
        end
      end
    end
    buffer = ""
  end
  --------------------------------------------
  -- Log Functions
  --------------------------------------------
  function getLogEntry()
    Controls.LogMsg.Choices = {}
    executeCommand("/log/print", function(data, hasErr, errMsg)
      local logs = {}
      Controls.LogMsg.Choices = {}
      Controls.LogMsg.String = ""
      if hasErr then
        if DebugFunc then print("Error fetching logs:", errMsg) end
        Controls.LogMsg.String = "Error fetching logs: " .. (errMsg or "Unknown error")
        return
      end
      for index, logEntry in ipairs(data) do
        local time = logEntry.time or "N/A"
        local topics = logEntry.topics or "N/A"
        local message = logEntry.message or "N/A"
        local critical = topics:match('critical') and "\a" .. topics or topics
        local displayString = string.format("[No.%d] %s [%s] %s", index-1, time, topics, message)
        local entry = {Text = displayString}
        if topics:match('critical') then entry.Color = "red"
        elseif topics:match('error') then entry.Color = "red"
        elseif topics:match('warning') then entry.Color = "blue"
        end
        table.insert(logs, entry)
      end
      Controls.LogMsg.Choices = logs
      print("Successfully loaded " .. #logs .. " log entries and set to Choices.")
    end)
  end
  --------------------------------------------
  -- Interface Visible Functions // include LinkSpeed, PoE Status
  --------------------------------------------
  function poeInterfaceVisible(index, visible)
    for _, iface in ipairs(IsInvisible_PoE_MAPPING) do
      Controls[iface][index].IsInvisible = visible
    end
  end
  
  function getInterfaceVisible()
    executeCommand("/interface/ethernet/poe/print =.proplist=name,default-name", function(poeData, poeErr)
      if poeErr then return end
      for _, item in ipairs(poeData) do
        if not item["default-name"] then item["default-name"] = item.name end
      end
  
      sortPort(poeData)
      local poePorts = {}
      for _, item in ipairs(poeData) do table.insert(poePorts, item.name) end
  
      executeCommand("/interface/ethernet/print =.proplist=name,default-name", function(ifData, ifErr)
        if ifErr then return end
  
        for _, item in ipairs(ifData) do
          if not item["default-name"] then item["default-name"] = item.name end
        end
        sortPort(ifData)
  
        if not hasInitVisibility then
          local maxCount = #Controls.Interface
          for i = 1, maxCount do
            local invisible = (i > #ifData)
            for _, ctrlName in ipairs(IsInvisible_MAPPING) do
              if Controls[ctrlName] and Controls[ctrlName][i] then
                Controls[ctrlName][i].IsInvisible   = invisible
                Controls.PortLabel[i].IsInvisible    = invisible
                Controls.PortLabel[i].String         = i
              end
            end
          end
          hasInitVisibility = true
        end
  
        for i, iface in ipairs(ifData) do
          executeCommand("/interface/ethernet/monitor =numbers="..iface.name.." =once=", function(linkRows, linkErr)
            if not linkErr and linkRows[1] then
              Controls.LinkSpeed[i].String = (linkRows[1].status=="link-ok" and linkRows[1].rate) or "no-link"
            end
          end)
  
          local isPoe = false
          for _, nm in ipairs(poePorts) do
            if nm == iface.name then isPoe = true; break end
          end
  
          if isPoe then
            executeCommand("/interface/ethernet/poe/monitor =numbers="..iface.name.." =once=", function(poeRows, poeErr)
              if not poeErr and poeRows[1] then
                local p = poeRows[1]
                Controls.PoeStatus[i].Boolean          = (p["poe-out-status"]=="powered-on")
                Controls.PoeOutStatus[i].String        = p["poe-out-status"] or "N/A"
                Controls.PoeOutVoltage[i].String       = p["poe-out-voltage"] and (p["poe-out-voltage"].." V") or "N/A"
                Controls.PoeOutCurrent[i].String       = p["poe-out-current"] and (p["poe-out-current"].." mA") or "N/A"
                Controls.PoeOutPower[i].String         = p["poe-out-power"] and (p["poe-out-power"].." W") or "N/A"
                Controls["Enable/Disable PoE"][i].Boolean = Controls.PoeStatus[i].Boolean
              end
            end)
          else
            poeInterfaceVisible(i, true)
          end
        end
      end)
    end)
  end
  --------------------------------------------
  -- Formatting Functions
  --------------------------------------------
  -- Utility function to format uptime string from MikroTik
  function formatDuration(uptime)
    if not uptime then return "N/A" end
    local units = {["w"] = "w", ["d"] = "d", ["h"] = "h", ["m"] = "m", ["s"] = "s", ["ms"] = "ms"} -- Added ms
    local result = {}
    -- Updated pattern to correctly capture numbers and units, including 'ms'
    for number_str, unit in string.gmatch(uptime, "(%d+)([a-z]+)") do
      local number = tonumber(number_str)
      if units[unit] and number and number > 0 then -- Ensure number is valid and > 0
        table.insert(result, number .. units[unit])
      end
    end
    return table.concat(result, " ")
  end
  -- Utility function to format byte counts
  function formatByte(byte)
    local bytes = tonumber(byte)
    if not bytes or bytes < 0 then return "N/A" end
    local units = {"", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"}
    local i = 1
    local size = bytes
    while size >= 1024 and i < #units do
      size = size / 1024
      i = i + 1
    end
    -- Format to one or two decimal places depending on size
    if size < 10 then return string.format("%.2f %s", size, units[i])
    else return string.format("%.1f %s", size, units[i])
    end
  end
  -- Utility function to format large numbers with thousands separators
  function formatCast(number)
    local num_str = tostring(tonumber(number))
    if num_str == "nil" or num_str == "nan" then return "N/A" end -- Handle non-numeric or NaN input
    local len = #num_str
    local formatted = ""
    local count = 0
    -- Iterate from the end of the string
    for i = len, 1, -1 do
      formatted = num_str:sub(i, i) .. formatted
      count = count + 1
      if count % 3 == 0 and i > 1 then
        formatted = "," .. formatted -- Prepend separator (use "." for some locales if needed)
      end
    end
    return formatted
  end
  --------------------------------------------
  -- Socket Event handlers
  --------------------------------------------
  sock.Connected = function()
    print("Connected to MikroTik")
    state = "login"
    polltimer:Start(tonumber(Properties["Poll Rate(sec)"].Value) ) -- Properties["Poll Rate(sec)"] must 1-600 sec
    executeCommand("/login =name=" .. user .. " =password=" .. pass, function(data, hasErr, errMsg)
      if not hasErr then
        status.Value = 0
        status.String = "Authentication successful!"
        print("Authentication successful!")
        state = "ready"
  
        executeCommand("/interface/ethernet/print =.proplist=name,default-name", function(data, hasErr, errMsg)
          if not hasErr then
            sortPort(data)
            interfacesName, defaultName = {}, {}
            for _, item in ipairs(data) do
              table.insert(interfacesName, item.name)
              table.insert(defaultName, item["default-name"])
            end
            Controls.InterfaceToCore.Choices = interfacesName -- CorePort table
          end
        end)
        if not initLogin then
          updateUI("/system/identity/print =.proplist=name", { SystemName = "name" })
          -- Updated mapping for system resource to use formatDuration for Uptime
          updateUI("/system/resource/print =.proplist=uptime,version", {
            Uptime = { attr = "uptime", formatter = function(v) return formatDuration(v) end },
            FirmwareVersion = "version",
            BoardName = "board-name"
          })
          updateUI("/system/license/print =.proplist=software-id,nlevel", { SoftwareID = "software-id", nLevel = "nlevel" })
          updateUI("/system/routerboard/print =.proplist=model,serial-number", { Model = "model", SerialNumber = "serial-number", FirmwareType = "firmware-type", FactoryFirmwareVersion = "factory-firmware" })
          updateUI("/interface/ethernet/print", INTERFACE_MAPPING, true) -- All Status
          getInterfaceVisible()
          initLogin = true
        end
      else
        status.Value = 2
        status.String = "Authentication failed"
        print("Authentication failed")
      end
    end)
  end
  
  sock.Data = function()
    buffer = buffer .. sock:Read(sock.BufferLength)
    processBuffer()
  end
  sock.Error = function(_, err)
    print("Socket error:", err)
    initLogin, state, buffer = false, "init", ""
    status.Value = 3
    status.String = "Socket error: " .. err
    polltimer:Stop()
  end
  sock.Closed = function()
    print("Socket closed. Reconnecting in 5 seconds...")
    initLogin, state, buffer = false, "init", ""
    status.Value = 4
    status.String = "Disconnected. Reconnecting..."
    polltimer:Stop()
  end
  
  --------------------------------------------
  -- Control EventHandlers
  --------------------------------------------
  Controls["IPAddress"].EventHandler   = function() Setup() Connect() end
  Controls["APIUsername"].EventHandler = function() Setup() Connect() end
  Controls["APIPassword"].EventHandler = function() Setup() Connect() end
  Controls["GetLog"].EventHandler      = function() getLogEntry() end
  Controls["LogClear"].EventHandler    = function() Controls.LogMsg.Choices = {} end
  Controls["SSHUsername"].EventHandler = function() Setup() end
  
  Controls["SSHPassword"].EventHandler = function()
    local passInput = Controls["SSHPassword"].String
    Controls["RealSSHPass"].String = passInput
    Setup()
    Controls["SSHPassword"].String = Controls["SSHPassword"].String ~= "" and Controls["SSHPassword"].String:gsub(".", "*") or Controls["SSHPassword"].String
  end
  -- Function to update visibility of InterfaceToCore related controls (per-interface action buttons/controls)
  function updateInterfaceToCoreUI()
    local selectedPort = Controls.InterfaceToCore.String
    local selectedIndex = 0 -- Initialize to 0 to indicate no match found yet
    local corePortChoices = Controls.InterfaceToCore.Choices
    local maxifCount = #Controls["Interface"]
    -- Find the 1-based index in the UI list corresponding to the selected port string
    for i, choice in ipairs(corePortChoices) do
      if choice == selectedPort then selectedIndex = i break end
    end
    for i = 1, maxifCount do
      local isSelectedPortRow = (i == selectedIndex and selectedIndex > 0)
      for _, ctrlName in ipairs({"Enable/Disable Port","Enable/Disable PoE"}) do
        if Controls[ctrlName] and Controls[ctrlName][i] then
          Controls[ctrlName][i].IsDisabled = isSelectedPortRow
        end
      end
    end
  end
  updateInterfaceToCoreUI()
  
  Controls.InterfaceToCore.EventHandler = function() updateInterfaceToCoreUI() end
  Controls.Reboot.EventHandler = function() executeCommand("/system/reboot") status.Value = 5 status.String = "Rebooting..." end
  -- PoE Enable/Disable
  for i, ctrl in ipairs(Controls["Enable/Disable PoE"]) do
    ctrl.EventHandler = function()
      local ifaceName = Controls["Interface"][i].String
      local poeMode = ctrl.Boolean and "auto-on" or "off"
      local cmd = '/interface/ethernet/poe/set =numbers=' .. ifaceName .. ' =poe-out=' .. poeMode .. ''
      executeCommand(cmd, function(data, hasErr, errMsg)
        if not hasErr then getInterfaceVisible() end
      end)
    end
  end
  -- Port Enable/Disable
  for i, ctrl in ipairs(Controls["Enable/Disable Port"]) do
    ctrl.EventHandler = function()
      local ifaceName = Controls["Interface"][i].String
      local disabledVal = ctrl.Boolean and "false" or "true"
      local cmd = '/interface/ethernet/set =numbers="' .. ifaceName .. '" =disabled=' .. disabledVal
      executeCommand(cmd, function(data, hasErr, errMsg)
        if not hasErr then getInterfaceVisible() end
      end)
    end
  end
  -- Comment
  for i, ctrl in ipairs(Controls["Comment"]) do
    ctrl.EventHandler = function()
      local comment = Controls["Comment"][i].String
      local cmd = '/interface/ethernet/set =.id=' .. defaultName[i] .. '" =comment=' .. comment
      executeCommand(cmd, function(data, hasErr, errMsg)
        if not hasErr then updateUI("/interface/ethernet/print", INTERFACE_MAPPING, true) end
      end)
    end
  end
  --------------------------------------------
  -- Connection functions
  --------------------------------------------
  function Connect()
    if sock.IsConnected then sock:Disconnect() end
    buffer = ""
    sock:Connect(address, port)
    status.Value = 5
    status.String = "Connecting to MikroTik..."
    print("Connecting to MikroTik " .. address .. ":" .. port)
  end
  
  function Disconnect()
    if sock.IsConnected then
      sock:Close()
      print("Disconnected from MikroTik")
      polltimer:Stop()
    end
    buffer = ""
    status.Value = 4
    status.String = "Disconnected"
  end
  --------------------------------------------
  -- Auto-connect on startup
  --------------------------------------------
  Setup()
  Connect()
  --------------------------------------------
  -- PollingTimer function
  --------------------------------------------
  polltimer.EventHandler = function()
    if sock.IsConnected then
      updateUI("/interface/ethernet/print", INTERFACE_MAPPING, true)
      updateUI("/system/resource/print =.proplist=uptime", {
        Uptime = { attr = "uptime", formatter = function(v) return formatDuration(v) end } }
      )
      executeCommand("/interface/bridge/host/print =.proplist=interface,mac-address,local", function(hosts, err, msg)
        if err then
          print("Error fetching bridge hosts: " .. (msg or "unknown"))
        else
          for idx, ifName in ipairs(interfacesName) do
            local foundMac = ""
            for _, host in ipairs(hosts) do
              if host.interface == ifName
                and host["mac-address"]
                and host["local"] == "false"
              then
                foundMac = host["mac-address"]
                break
              end
            end
            if Controls.DeviceMAC and Controls.DeviceMAC[idx] then
              Controls.DeviceMAC[idx].String = foundMac
            end
          end
        end
        getInterfaceVisible()
      end)
    else
      polltimer:Stop()
    end
  end
  --------------------------------------------
  -- SSH-connect for CLI
  --------------------------------------------
  local ssh = Ssh.New()
  ssh.ReadTimeout = 0
  ssh.WriteTimeout = 0
  ssh.ReconnectTimeout = 5
  ssh.IsInteractive = false -- Use Connect with credentials
  
  local sshTimer = Timer.New() -- Inactivity timeout timer
  local setTimeout = Controls["SSHTimeOut"].Value -- Configured timeout value (seconds)
  local timeoutCount = 0 -- Current countdown value (seconds)
  
  -- Handle connection status and log messages
  function connectionStatus(isConnected, msg)
    Controls.SSHConnected.Boolean = isConnected
    local timestamp = os.date("%Y-%m-%dT%H:%M:%S")
    print(msg)
    Controls.SSHOutput.String = Controls.SSHOutput.String .. "\n" .. timestamp .. " " .. msg
    -- Stop timer on disconnect
    if isConnected == false then stopSshTimer() end
  end
  
  -- Stop timeout timer and reset countdown
  function stopSshTimer()
    sshTimer:Stop()
    timeoutCount = 0
    print("SSH inactivity timeout timer stopped.")
    Controls["SSHTimeOutDisplay"].String = ""
  end
  
  --------------------------------------------
  -- SSH socket callbacks
  --------------------------------------------
  -- Called when SSH is connected and authenticated
  ssh.Connected = function()
    connectionStatus(true, "SSH connected.")
    -- Start timer if timeout is configured
    if setTimeout > 0 then
      timeoutCount = setTimeout
      sshTimer:Start(1) -- 1-second interval
      print("SSH inactivity timeout timer started: " .. timeoutCount .. "s.")
      Controls["SSHTimeOutDisplay"].String = timeoutCount
    else
      print("SSH inactivity timeout disabled.")
    end
  end
  -- Called when data is received from SSH server
  ssh.Data = function()
    local line = ssh:ReadLine(TcpSocket.EOL.Any)
    while line do
      local timestamp = os.date("%Y-%m-%dT%H:%M:%S")
      local cleanedLine = string.gsub(line, "^%s*", "")
      Controls.SSHOutput.String = Controls.SSHOutput.String .. "\n" .. timestamp .. " " .. cleanedLine
      print("SSH Data: " .. line) -- Debug
      line = ssh:ReadLine(TcpSocket.EOL.Any)
    end
  end
  
  ssh.Reconnect = function() print("SSH reconnect attempt...") end
  ssh.Closed = function() connectionStatus(false, "SSH closed.") end
  ssh.Error = function(s, err) connectionStatus(false, "SSH Error: " .. err) end
  ssh.Timeout = function() connectionStatus(false, "SSH connection timeout.") end
  ssh.LoginFailed = function() connectionStatus(false, "SSH Login Failed.") end
  
  -- SSH Inactivity Timer EventHandler
  sshTimer.EventHandler = function()
    if ssh.IsConnected then
      timeoutCount = timeoutCount - 1
      if Controls["SSHTimeOutDisplay"] then Controls["SSHTimeOutDisplay"].String = timeoutCount end
        print("SSH countdown: " .. timeoutCount) -- Debug
      if timeoutCount <= 0 then
        print("SSH connection timed out due to inactivity.")
        ssh:Disconnect()
        Controls["SSHUsername"].String, Controls["SSHPassword"].String,Controls["SSHInput"].String = "","",""
        stopSshTimer() -- Ensure stopped immediately
      else
        sshTimer:Start(1) -- Restart for next tick
      end
    else
      stopSshTimer() -- Stop if connection lost while timer running
    end
  end
  
  -- SSHConnect button pressed
  Controls.SSHConnect.EventHandler = function()
    Controls.SSHTimeOutDisplay.String = "Start"
    Setup()
    -- Connect only if disconnected
    if not ssh.IsConnected then
      -- Log attempt
      Controls.SSHOutput.String = Controls.SSHOutput.String .. "\n" .. os.date("%Y-%m-%dT%H:%M:%S") .. " Connecting SSH to " .. address .. "..."
      print("Attempting SSH connection to " .. address .. " as user " .. sshuser)
      -- Connect with credentials (requires 4 args)
      ssh:Connect(address, sshport, sshuser, sshpass)
    else
      print("SSH: Already connected.")
      Controls.SSHOutput.String = Controls.SSHOutput.String .. "\n" .. os.date("%Y-%m-%dTH:%M:%S") .. " SSH: Already connected."
    end
  end
  
  -- SSHDisconnect button pressed
  Controls.SSHDisconnect.EventHandler = function()
    Controls.SSHConnected.Boolean = false
    if ssh.IsConnected then
      print("Disconnecting SSH...")
      ssh:Disconnect()
      Controls["SSHUsername"].String, Controls["SSHPassword"].String,Controls["SSHInput"].String = "","",""
    end
    stopSshTimer() -- Ensure timer stops on button press
  end
  
  -- SSHSend button or Enter key pressed
  Controls.SSHSend.EventHandler = function()
    if ssh.IsConnected then
      local cmd = Controls.SSHInput.String
      if cmd == "" then if DebugTx then print("SSH: Cannot send empty command.") return end end
      local commandToSend = cmd .. "\n"
      local timestamp = os.date("%Y-%m-%dT%H:%M:%S")
      if DebugTx then print("Sending SSH command: " .. string.gsub(commandToSend, "\n", "\\n")) end
      ssh:Write(commandToSend)
      Controls.SSHOutput.String = Controls.SSHOutput.String .. "\n" .. timestamp .. " Send >> " .. cmd
      -- Reset inactivity timeout on activity
      if setTimeout > 0 then
        timeoutCount = setTimeout; sshTimer:Start(1)
        print("SSH timeout reset by send activity: " .. timeoutCount .. "s.")
        Controls["SSHTimeOutDisplay"].String = timeoutCount
      end
      Controls["SSHInput"].String = ""
    end
  end
  
  -- SSHClear output button pressed
  Controls.SSHClear.EventHandler = function()
    Controls.SSHOutput.String = ""
    print("SSH Output cleared.")
  end
  
  -- SSHTimeOut value changed
  Controls.SSHTimeOut.EventHandler = function()
    setTimeout = Controls["SSHTimeOut"].Value or 0 -- Read new value
    if setTimeout > 0 then
      if DebugFunc then print("SSH timeout set to: " .. setTimeout .. "s.") end
      if ssh.IsConnected then
        timeoutCount = setTimeout; sshTimer:Start(1) -- Apply & restart if connected
        if DebugFunc then print("SSH timeout timer updated & started.") end
        if Controls["SSHTimeOutDisplay"] then Controls["SSHTimeOutDisplay"].String = timeoutCount end
      end
    else -- Timeout disabled (0)
      if DebugRx then print("SSH timeout disabled.") end
      stopSshTimer() -- Stop timer
    end
  end
end